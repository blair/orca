    <HTML> 
	<HEAD> 
	    <TITLE>rrdtutorial - Alex van den Bogaerdts RRD Tool tutorial

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->
<!--

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#TUTORIAL">TUTORIAL</A>
	<UL>

		<LI><A HREF="#Important">Important</A>
		<LI><A HREF="#What_is_RRDtool_">What is RRDtool ?</A>
		<LI><A HREF="#What_data_can_be_put_into_an_RDD">What data can be put into an RDD ?</A>
		<LI><A HREF="#What_can_I_do_with_this_tool_">What can I do with this tool ?</A>
		<LI><A HREF="#What_if_I_still_have_problems_af">What if I still have problems after reading this document ?</A>
		<LI><A HREF="#How_will_you_help_me_">How will you help me ?</A>
		<LI><A HREF="#Your_first_Round_Robin_Database">Your first Round Robin Database</A>
		<LI><A HREF="#What_has_been_created_">What has been created ?</A>
		<LI><A HREF="#It_is_time_to_create_some_graphi">It is time to create some graphics</A>
		<LI><A HREF="#Graphics_with_some_math">Graphics with some math</A>
		<LI><A HREF="#Graphics_Magic">Graphics Magic</A>
		<LI><A HREF="#Updates_in_Reality">Updates in Reality</A>
		<LI><A HREF="#Some_words_on_SNMP">Some words on SNMP</A>
		<LI><A HREF="#A_Real_World_Example">A Real World Example</A>
		<LI><A HREF="#Consolidation_Functions">Consolidation Functions</A>
		<LI><A HREF="#Let_s_review_what_you_now_should">Let's review what you now should know.</A>
		<LI><A HREF="#Data_Source_Types">Data Source Types</A>
		<LI><A HREF="#RRD_Tool_under_the_Microscope">RRD Tool under the Microscope</A>
		<LI><A HREF="#Counter_Wraps">Counter Wraps</A>
		<LI><A HREF="#Data_Resampling">Data Resampling</A>
	</UL>

	<LI><A HREF="#WRAPUP">WRAPUP</A>
	<LI><A HREF="#MAILINGLIST">MAILINGLIST</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
</UL>
-->
<!-- INDEX END -->

<P>
<H1><A NAME="NAME">NAME

</A></H1>
rrdtutorial - Alex van den Bogaerdts RRD Tool tutorial


<P>

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>
RRDtool is written by Tobias Oetiker <A
HREF="MAILTO:<oetiker@ee.ethz.ch>"><oetiker@ee.ethz.ch></A> with
contributions from many people all around the world. This document is
written by Alex van den Bogaerdt <A
HREF="MAILTO:<alex@ergens.op.het.net>"><alex@ergens.op.het.net></A> to help
you understand what RRDtool is and what it can do for you.


<P>

The documentation provided with RRDtool can be too technical for some
people and here we help you to understand the basics in order to prepare
you to read the documentation yourself. It also explains the general things
about statistics with a focus on networking.


<P>

<P>
<HR>
<H1><A NAME="TUTORIAL">TUTORIAL

</A></H1>
<P>
<HR>
<H2><A NAME="Important">Important

</A></H2>
We first have to do some uninteresting reading folks, don't skip this part!
Later on, in the examples, you need to know the basics.


<P>

<P>
<HR>
<H2><A NAME="What_is_RRDtool_">What is RRDtool ?

</A></H2>
RRDtool means Round Robin Database tool. Round robin is a technique that
works with a fixed amount of data, and a pointer to the current element.
Think of a circle with some dots plotted on the edge, these dots are the
places where data can be stored. Draw an arrow from the center of the
circle to one of the dots, this is the pointer. When the current data is
read or written, the pointer moves to the next element. As we are on a
circle there is no beginning nor an end, you can go on and on. After a
while, all the available places will be used and the process automatically
reuses old locations. RRDtool works with with Round Robin Databases (RRDs).
It stores and retrieves data from them.


<P>

<P>
<HR>
<H2><A NAME="What_data_can_be_put_into_an_RDD">What data can be put into an RDD ?

</A></H2>
You name it, it will probably fit. You should be able to measure some value
at several points in time and provide this to RRDtool. If you can do this,
RRDtool will probably be able to store it.


<P>

Many examples talk about SNMP which is an acronym for Simple Network
Management Protocol. The ``simple'' is about the protocol, it does not mean
it is simple to manage a network. After working your way through this
document, you will know enough to be able to understand what people are
talking about. For now, just assume SNMP is a way to talk to devices and
ask those devices about counters they keep. It is the value from those
counters that are kept in the RRD.


<P>

<P>
<HR>
<H2><A NAME="What_can_I_do_with_this_tool_">What can I do with this tool ?

</A></H2>
RRDtool originated from MRTG (multi router traffic grapher) which itself
came from a tiny little script to monitor the performance of a connection
to the Internet. Since then, MRTG has also been used for several other
purposes including temperature, speed, voltage, number of printouts and
many other things. Most likely you will start to use the RRDtool to store
and process data collected via SNMP. The data will most likely be bytes (or
bits) transfered from and to a network or a computer. RRDtool lets you
create a database, store data in it, retrieve that data and create graphs
in GIF format for display on a web browser. Those GIF images are dependant
on the data you collected and could be, for instance, an overview of the
average network usage, or rather the peaks that occurred. It can also be
used to display tidal waves, solar radiation, power consumption, number of
visitors at an exibition, noise levels near an airport, temperature on your
favorite holiday location, temperature in the fridge and whatever you
imagination can come up with. You need a sensor to measure the data and be
able to feed the numbers to RRDtool. Many devices have such a sensor.


<P>

<P>
<HR>
<H2><A NAME="What_if_I_still_have_problems_af">What if I still have problems after reading this document ?

</A></H2>
More exact, after re-reading this document :) It all depends on the kind of
problems you have. If you are unable to compile the sources and you have a
fairly common OS, it will probably not be the fault of RRDtool. There may
be precompiled versions around on the Internet. If they come from trusted
sources, get one of those. If on the other hand the program works but does
not give you the expected results, it will be a problem with configuring
it. Review your configuration and compare it with the examples that follow.


<P>

There is a mailing list and an archive of it. Read the list for a few weeks
and search the archive. It is considered rude to just ask a question
without reading the list, your problem may already have been solved for
somebody else and you will be helped without writing a new a message at all
... This is true for most, if not all, mailing lists and not only for this
particular list! Look in the documentation that came with RRDtool for the
location and usage of the list.


<P>

I suggest you take a moment to subscribe to the mailing list right now by
sending an email to <A
HREF="MAILTO:<rrdtool-users-request@list.ee.ethz.ch>"><rrdtool-users-request@list.ee.ethz.ch></A>
with a subject of ``subscribe''. If you ever want to leave this list, you
write an email to the same address but now with a subject of
``unsubscribe''.


<P>

<P>
<HR>
<H2><A NAME="How_will_you_help_me_">How will you help me ?

</A></H2>
By giving you some detailed descriptions with detailed examples. It is
assumed that following the instructions in the order presented will build
up enough knowledge of the program to experiment for yourself. If it
doesn't work the first time, don't give up. Reread the stuff that you did
understand, you may have missed something. By following the examples you
get some hands-on experience and, even more important, some background
information of how it works.


<P>

You will need to know something about hexadecimal numbers. If you don't
then start with reading ``bin_dec_hex'' before you continue here.


<P>

<P>
<HR>
<H2><A NAME="Your_first_Round_Robin_Database">Your first Round Robin Database

</A></H2>
In my opinion the best way to learn something is to actually do it. Why not
start right now? We will create a database, put some values in it and
extract this data again. It is expected that you get the same results when
you try these examples yourself so do that. We will start with some easy
stuff and compare a car with a router, or compare kilometers (miles if you
wish) with bits and bytes. It's all the same: Some number over some time.


<P>

Assume we have a device that transfers bytes to and from the Internet. This
device keeps a counter that starts at zero when it is turned on, increasing
with every byte that is transfered. This counter will have a maximum value,
if that value is reached and an extra byte is counted, the counter starts
all over at zero. This is the same as many counters in the world such as
the mileage counter in a car. Most discussions about networking talk about
bits per second so lets get used to that right away. Assume a byte is eight
bits and start to think in bits not bytes. The counter however still counts
bytes ! In the SNMP world most of the counters are 32 bits. That means they
are counting from 0 to 4294967295. We will use these values in the
examples. The device, when asked, returns the current value of the counter.
We know the time that has passes since we last asked so we now know how
many bytes have been transfered <CODE>***on</CODE> average*** per second.
This is not very hard to calculate. First in words, then in calculi:


<P>

<OL>
<LI><STRONG><A NAME="item_">

</A></STRONG>
Take the current counter, subtract the previous value from it.


<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
Do the same with the current time and the previous time.


<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
Divide the outcome of (1) by the outcome of (2), the result is the amount
of bytes per second. Multiply by eight to get the number of bits per second
(bps).


<P>

<PRE>  bps = (counter_now - counter_before) / (time_now - time_before) * 8
</PRE>

<P>

</OL>
For some people it may help to translate this to a automobile example: Do
not try this example, and if you do, don't blame me for the results.


<P>

People who are not used to think in kilometers per hour can translate most
into miles per hour by dividing km by 1.6 (close enough). I will use the
following abbreviations:


<P>

<PRE> M:    meter
 KM:   kilometer (= 1000 meters).
 H:    hour
 S:    second
 KM/H: kilometers per hour
 M/S:  meters per second
</PRE>

<P>

You're driving a car. At 12:05 you read the counter in the dashboard and it
tells you that the car has moved 12345 KM until that moment. At 12:10 you
look again, it reads 12357 KM. This means you have traveled 12 KM in five
minutes. A scientist would translate that into meters per second and this
makes a nice comparison towards the problem of (bytes per five minutes)
versus (bits per second).


<P>

We traveled 12 kilometers which is 12000 meters. We did that in five
minutes which translates into 300 seconds. Our speed is 12000M / 300S
equals 40 M/S.


<P>

We could also calculate the speed in KM/H: twelve times five minutes is an
hour so we have to multiply 12 KM by 12 to get 144 KM/H. For our native
English speaking friends: this is ninety MPH and therefore not recommended
to try for yourself where I live :)


<P>

Remember: these numbers are averages and there is no way to figure out from
the numbers we got that you drove at a constant speed.


<P>

I hope you understand that there is no difference in calculating M/S or
bps, only the way we collect the data is different. Even the K from kilo is
the same as in networking terms k also means 1000.


<P>

We will now create a database where we can keep all these interesting
numbers. The method used to start the program may differ slightly from OS
to OS but I assume you can figure it out if it works different on your OS.
Make sure you do not overwrite any file on your system when executing the
following command (so: first look if it's safe!) and type the whole line as
one long line (I had to split it for readability) and skip all of the '\'
characters.


<P>

<PRE>   rrdtool create test.rrd             \
            --start 920804400          \
            DS:speed:COUNTER:600:U:U   \
            RRA:AVERAGE:0.5:1:24       \
            RRA:AVERAGE:0.5:6:10
</PRE>

<P>

(So enter: <CODE>rrdtool create test.rrd --start 920804400 DS ...</CODE>)


<P>

<P>
<HR>
<H2><A NAME="What_has_been_created_">What has been created ?

</A></H2>
We created the round robin database called test (test.rrd) which starts at
noon the day I started (7th of march, 1999) writing this document. It holds
one data source (DS) named ``speed'' that gets built from a counter. This
counter is read every five minutes (default) In the same database two round
robin archives (RRAs) are kept, one averages the data every time it is read
(so: there's nothing to average) and keeps 24 samples (24 times 5 minutes
is 2 hours). The other averages 6 values (half hour) and contains 10 of
such averages (so: 5 hours) The remaining options will be discussed later
on. Chances are that you are not in the same part of the world as I am.
This means your time zone is different. In all examples where I talk about
time, the hours may be wrong for you. This has little effect on the results
of the examples, just correct the hours while reading.


<P>

We now have to fill our database with some numbers. We'll pretend to have
read the following numbers:


<P>

<PRE> 12:05  12345 KM
 12:10  12357 KM
 12:15  12363 KM
 12:20  12363 KM
 12:25  12363 KM
 12:30  12373 KM
 12:35  12383 KM
 12:40  12393 KM
 12:45  12399 KM
 12:50  12405 KM
 12:55  12411 KM
 13:00  12415 KM
 13:05  12420 KM
 13:10  12422 KM
 13:15  12423 KM
</PRE>

<P>

We fill the database as follows:


<P>

<PRE> rrdtool update test.rrd 920804700:12345 920805000:12357 920805300:12363
 rrdtool update test.rrd 920805600:12363 920805900:12363 920806200:12373
 rrdtool update test.rrd 920806500:12383 920806800:12393 920807100:12399
 rrdtool update test.rrd 920807400:12405 920807700:12411 920808000:12415
 rrdtool update test.rrd 920808300:12420 920808600:12422 920808900:12423
</PRE>

<P>

This reads: update our test database with the following numbers


<P>

<PRE> time 920804700, value 12345
 time 920805000, value 12357
</PRE>

<P>

etcetera.


<P>

As you can see, it is possible to feed more than one value into the
database in one command. I had to stop at three for readability but the
real maximum will be OS dependent.


<P>

The time value may look strange to you, it is written in seconds since the
first of January, 1970, midnight. Don't worry about this yet, just notice
that there is a difference of 300 in between all values.


<P>

<P>
<HR>
<H2><A NAME="It_is_time_to_create_some_graphi">It is time to create some graphics

</A></H2>
Try the following command:


<P>

<PRE> rrdtool graph speed.gif                                 \
         --start 920804400 --end 920808000               \
         DEF:myspeed=test.rrd:speed:AVERAGE              \
         LINE2:myspeed#FF0000
</PRE>

<P>

This will create speed.gif which starts at 12:00 and ends at 13:00. There
is a definition of variable myspeed, it is the data from RRA ``speed'' out
of database ``test.rrd''. The line drawn is 2 pixels high, and comes from
variable myspeed. The color is red. You'll notice that the start of the
graph is not at 12:00 but at 12:05 and this is because we have insufficient
data to tell the average before that time. This will only happen when you
miss some samples, this will not happen a lot, hopefully.


<P>

If this has worked: Congratulations. If not, check what went wrong.


<P>

The colors are built up from red, green and blue. For each of the
components, you specify how much to use in hexadecimal where 00 means not
included and FF means fully included. The color white is a mixture of red,
green and blue: FFFFFF The color black is all colors off: 000000 (Please,
no discussions if black and white can be called colors)


<P>

<PRE>   red    #FF0000
   green  #00FF00
   blue   #0000FF
   purple #FF00FF     (mixed red with blue)
   gray   #555555     (one third of all components)
</PRE>

<P>

The GIF you just created can be displayed using a web browser or other
software you like. I can not provide you with an example of that, because
there are too many different setups, possibilities etc.


<P>

<P>
<HR>
<H2><A NAME="Graphics_with_some_math">Graphics with some math

</A></H2>
When looking at the image, you notice that the horizontal axis displays
12:10, 12:20, 12:30, 12:40 and 12:50. The two remaining times (12:00 and
13:00) would not be displayed nicely so they are skipped. The vertical axis
displays the range we entered. We provided kilometers and when divided by
300 seconds, we get very small numbers. To be exact, the first value was 12
(12357-12345) and divided by 300 this makes 0.04 RRDtool displays this as
40 m which means 40 mili (so: NOT meters). What we did wrong was that we
should have measured in meters, this would have been
(12357000-12345000)/300 = 12000/300 = 40.


<P>

Let's correct that. We could recreate our database and store the correct
data but there is another way: do some calculations while creating the gif
file !


<P>

<PRE>   rrdtool graph speed2.gif                           \
      --start 920804400 --end 920808000               \
      --vertical-label m/s                            \
      DEF:myspeed=test.rrd:speed:AVERAGE              \
      CDEF:realspeed=myspeed,1000,*                   \
      LINE2:realspeed#FF0000
</PRE>

<P>

After viewing this GIF, you notice the ``m'' has disappeared. This it what
the correct result would be. Also, a label has been added to the image.
Apart from the things mentioned above, the GIF should be the same.


<P>

The calculations are done with the CDEF part. What it says is: take the
data source myspeed and the number 1000, multiply those. The calculations
are done using Reverse Polish Notation. It is an easy way of performing
calculations after you understand it. You will, eventually but for now
assume it is correct what I write and just keep to the examples in this
file. Read the documentation that came with RRDtool (look in rrdgraph.doc)
when you're ready for it.


<P>

Hang on! If we can multiply values with 1000, it should also be possible to
display kilometers per hour from the same data ! What do we need to do ? If
we have meters per second, we can make this meters per hour by multiplying
the value with 3600 (there go 3600 seconds in one hour). To get kilometers
per hour, we need to divide by 1000. We end up with: value * 3600 / 1000 =
value * 3.6 . Remember we also have to correct our mistake, so it is value
* 3600 for us.


<P>

Now let's create this GIF, and add some more magic ...


<P>

<PRE>   rrdtool graph speed3.gif                           \
      --start 920804400 --end 920808000               \
      --vertical-label km/h                           \
      DEF:myspeed=test.rrd:speed:AVERAGE              \
      CDEF:kmh=myspeed,3600,*                         \
      CDEF:fast=kmh,100,GT,kmh,0,IF                   \
      CDEF:good=kmh,100,GT,0,kmh,IF                   \
      HRULE:100#0000FF:&quot;Maximum allowed&quot;              \
      AREA:good#00FF00:&quot;Good speed&quot;                   \
      AREA:fast#FF0000:&quot;Too fast&quot;
</PRE>

<P>

This looks much better. Speed in KM/H and even an extra line with the
maximum allowed speed (on the road I travel at). I also changed the colors
used to display speed and changed it from a line into an area.


<P>

The calculations are more complex now. For the ``good'' speed they are:


<P>

<UL>
<LI><STRONG></STRONG>
Check if kmh is greater than 100 ( kmh,100 ) GT


<P>

<LI><STRONG></STRONG>
If so, return 0, else kmh ((( kmh,100 ) GT ), 0, kmh) IF


<P>

</UL>
For the other speed:


<P>

<UL>
<LI><STRONG></STRONG>
Check if kmh is greater than 100 ( kmh,100 ) GT


<P>

<LI><STRONG></STRONG>
If so, return kmh, else return 0 ((( kmh,100) GT ), kmh, 0) IF


<P>

</UL>
<P>
<HR>
<H2><A NAME="Graphics_Magic">Graphics Magic

</A></H2>
I like to believe there are virtually no limits about what RRDtool can do.
I will not explain how it works, but look at the following GIF:


<P>

<PRE>   rrdtool graph speed4.gif                           \
      --start 920804400 --end 920808000               \
      --vertical-label km/h                           \
      DEF:myspeed=test.rrd:speed:AVERAGE              \
      CDEF:kmh=myspeed,3600,*                         \
      CDEF:fast=kmh,100,GT,100,0,IF                   \
      CDEF:over=kmh,100,GT,kmh,100,-,0,IF             \
      CDEF:good=kmh,0,kmh,100,GT,IF                   \
      HRULE:100#0000FF:&quot;Maximum allowed&quot;              \
      AREA:good#00FF00:&quot;Good speed&quot;                   \
      AREA:fast#550000:&quot;Too fast&quot;                     \
      STACK:over#FF0000:&quot;Over speed&quot;
</PRE>

<P>

Let's create a quick and dirty HTML page to view three GIFs:


<P>

<PRE>   &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Speed&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;
   &lt;IMG src=&quot;speed2.gif&quot; alt=&quot;Speed in meters per second&quot;&gt;
   &lt;BR&gt;
   &lt;IMG src=&quot;speed3.gif&quot; alt=&quot;Speed in kilometers per hour&quot;&gt;
   &lt;BR&gt;
   &lt;IMG src=&quot;speed4.gif&quot; alt=&quot;Traveled too fast?&quot;&gt;
   &lt;/BODY&gt;&lt;/HTML&gt;
</PRE>

<P>

Name the file ``speed.html'' or similar, and view it.


<P>

Now, all you have to do is measure the values regularly and update the
database. Every time you create these three GIFs and reload the page and
the GIFs (better reread these last three words!) you know how fast you
traveled.


<P>

<P>
<HR>
<H2><A NAME="Updates_in_Reality">Updates in Reality

</A></H2>
You already looked at the ``update'' tool. It took one or more parameters
in the form of ``&lt;time&gt;:&lt;value&gt;''. You'll be glad to know that
you can get the current time by filling in a ``N'' as the time. If you
wish, you can also use the ``time'' function in perl. The shortest example
in this doc :)


<P>

<PRE>   perl -e 'print time, &quot;\n&quot; '
</PRE>

<P>

How you can run a program on regular intervals is OS specific, so I just
give you an example script in a sort of pseudo code: (Do not try this with
our test database, it is used in further examples)


<P>

<PRE>   Get the value, put it in variable &quot;$speed&quot;
   rrdtool update speed.rrd N:$speed
</PRE>

<P>

This is all. Run this script every five minutes. When you need to know what
the graphics look like, run the examples above. You could put them in a
script. After running that script, view index.html


<P>

<P>
<HR>
<H2><A NAME="Some_words_on_SNMP">Some words on SNMP

</A></H2>
I can imagine very few people will be able to get real data from their car
every five minutes, all other people will have to settle for some other
kind of counter. You could measure the number of pages printed by the
laser-jet printer, the coffee made by the coffee machine, a device that
counts the electricity used, whatever. Just as long as it is an
incrementing counter that you can measure regularly, you can graph it
against time as we did. Most people will use the counter that keeps track
of octets (bytes) transfered by a routing device so we have to do just
that. We will start with a description of how to collect data. Some people
will make a remark that there are tools who can do this data collection for
you. They are right! However, I feel it is important that you understand
they are not necessary. If you have to look why things went wrong, you need
to know how the stuff works.


<P>

One tool used in the example has been talked about very briefly in the
beginning of this document, it is called SNMP. It is a way of talking to
equipment. The tool I use below is called ``snmpget'' and this is how it
works:


<P>

<PRE>   snmpget device password OID
</PRE>

<P>

For device you substitute the name of your device, for password you use the
``community'' as it is called. For most devices ``public'' will do but this
can be disabled, altered or protected for privacy and security reasons. You
will need to find this out as there is no way I can tell what you ( ...your
device... ) are keeping a secret from me.


<P>

Then there is this third parameter, called OID. When you start to learn
about SNMP it looks very confusing. It isn't all that difficult when you
look at the Management Information Base or in short: the MIB. It is an
upside-down tree, with a single node as the root and from there a number of
branches. These branches end up in another node, they branch out, etc. All
the branches have a name and they form the path that we follow all the way
down. The branches that we follow are named: iso, org, dod, internet, mgmt
and mib-2. These names can also be written down as numbers and are 1 3 6 1
2 1.


<P>

<PRE>   iso.org.dod.internet.mgmt.mib-2 (1.3.6.1.2.1)
</PRE>

<P>

From there, we are especially interested in the branch ``interfaces'' which
has number 2 (so: 1.3.6.1.2.1.2 or 1.3.6.1.2.1.interfaces).


<P>

The SNMP programs that I know can take above path as a default, so I could
walk to interfaces without writing it in full. To do that, the path has to
be written as interfaces, without a leading dot. I could also use the long
form, then I need to start with a dot.


<P>

I can intermix numbers and names as I like. 1.3.6.1.2.1 is the same as
iso.org.dod.1.2.1 and 1.3.6.internet.2.mib-2 For interfaces I could write
``interfaces'', 2, or a long version by prefixing it with
``.1.3.6.1.2.1.''. Just try what works for you and do read the manual for
the version of snmpget you are using.


<P>

First, we have to get some SNMP program. First look if there is a
pre-compiled package available for your OS. This is the preferred way. If
not, you will have to get yourself the sources and compile those. The
Internet is full of sources, programs etc. Find information using a search
engine or whatever you prefer. You are on your own here, sorry.


<P>

Assume you got the program. First try to collect some data that is
available on most systems. Remember: there is a short name for the part of
the tree that interests us most in the world we live in ! I will use the
short version as I think this document is large enough as it is. If that
doesn't work for you, prefix with .1.3.6.1.2.1 and try again. Also, Read
The Fine Manual. Skip the parts you cannot understand yet, you should be
able to find out how to start the program and use it.


<P>

<PRE>   snmpget myrouter public system.sysdescr.0
</PRE>

<P>

The device should answer with a description of itself, perhaps empty. Until
you got a valid answer from a device, perhaps using a different
``password'', or a different device, there is no point in continuing.


<P>

<PRE>   snmpget myrouter public interfaces.ifnumber.0
</PRE>

<P>

Hopefully you get a number as a result, the number of interfaces. If so,
you can carry on and try a different program called ``snmpwalk''.


<P>

<PRE>   snmpwalk myrouter public interfaces.iftable.ifentry.ifdescr
</PRE>

<P>

If it returns with a list of interfaces, you're almost there. Here's an
example: [user@host /home/alex]$ snmpwalk cisco public 2.2.1.2


<P>

<PRE>   interfaces.ifTable.ifEntry.ifDescr.1 = &quot;BRI0: B-Channel 1&quot;
   interfaces.ifTable.ifEntry.ifDescr.2 = &quot;BRI0: B-Channel 2&quot;
   interfaces.ifTable.ifEntry.ifDescr.3 = &quot;BRI0&quot; Hex: 42 52 49 30
   interfaces.ifTable.ifEntry.ifDescr.4 = &quot;Ethernet0&quot;
   interfaces.ifTable.ifEntry.ifDescr.5 = &quot;Loopback0&quot;
</PRE>

<P>

On this cisco equipment, I would like to monitor the ``Ethernet0''
interface and see that it is number four. I try:


<P>

<PRE>   [user@host /home/alex]$ snmpget cisco public 2.2.1.10.4 2.2.1.16.4
</PRE>

<P>

<PRE>   interfaces.ifTable.ifEntry.ifInOctets.4 = 2290729126
   interfaces.ifTable.ifEntry.ifOutOctets.4 = 1256486519
</PRE>

<P>

So now I have two OIDs to monitor and they are (in full, this time):


<P>

<PRE>   1.3.6.1.2.1.2.2.1.10
</PRE>

<P>

and


<P>

<PRE>   1.3.6.1.2.1.2.2.1.16
</PRE>

<P>

both with an interface number of 4.


<P>

Don't get fooled, this wasn't my first try. It took some time for me too to
understand what all these numbers mean, it does help a lot when they get
translated into descriptive text... At least, when people are talking about
MIBs and OIDs you know what it's all about. Do not forget the interface
number (0 if it is not interface dependent) and try snmpwalk if you don't
get an answer from snmpget.


<P>

If you understand above part, and get numbers from your device, it is time
to continue with the following. If not, then go back.


<P>

<P>
<HR>
<H2><A NAME="A_Real_World_Example">A Real World Example

</A></H2>
Let the fun begin. First, create a new database. It contains data from two
counters, called input and output. The data is put into archives that
average it. They take 1, 6, 24 or 288 samples at a time. They also go into
archives that keep the maximum numbers. This will be explained later on.
The time in-between samples is 300 seconds, a good starting point, which is
the same as five minutes.


<P>

<PRE> 1 sample averaged stays 1 period of 5 minutes
 6 samples averaged become one average on 30 minutes
 24 samples averaged become one average on 2 hours
 288 samples averaged become one average on 1 day
</PRE>

<P>

<PRE> There are 600 samples of five minutes, together just over two days
 There are 600 samples of 30 minutes, almost two weeks
 There are 600 samples of 2 hours, 50 hour or almost two months
 There are 732 samples of 1 day, just over two years
</PRE>

<P>

For people used to MRTG that even have read the manuals, these numbers
should look familiar...


<P>

<PRE>   rrdtool create myrouter.rrd         \
            DS:input:COUNTER:600:U:U   \
            DS:output:COUNTER:600:U:U  \
            RRA:AVERAGE:0.5:1:600      \
            RRA:AVERAGE:0.5:6:600      \
            RRA:AVERAGE:0.5:24:600     \
            RRA:AVERAGE:0.5:288:732    \
            RRA:MAX:0.5:1:600          \
            RRA:MAX:0.5:6:600          \
            RRA:MAX:0.5:24:600         \
            RRA:MAX:0.5:288:732
</PRE>

<P>

Next thing to do is collect data and store it. Here is an example. It is
written partially in pseudo code so you will have to find out what to do
exactly on your OS to make it work.


<P>

<PRE>   while not the end of the universe
   do
      get result of
         snmpget router community 2.2.1.10.4
      into variable $in
      get result of
         snmpget router community 2.2.1.16.4
      into variable $out
</PRE>

<P>

<PRE>      rrdtool update myrouter.rrd N:$in:$out
</PRE>

<P>

<PRE>      wait for 5 minutes
   done
</PRE>

<P>

Then, after collecting data for a day, try to create an image using:


<P>

<PRE>   rrdtool graph myrouter-day.gif --start -86400 \
            DEF:inoctets=myrouter.rrd:input:AVERAGE \
            DEF:outoctets=myrouter.rrd:output:AVERAGE \
            AREA:inoctets#00FF00:&quot;In traffic&quot; \
            LINE1:outoctets#0000FF:&quot;Out traffic&quot;
</PRE>

<P>

This should produce a picture with one day worth of traffic. One day is 24
hours of 60 minutes of 60 seconds: 24*60*60=86400, we start at now minus
86400 seconds. We DEFine inoctets and outoctets as the average values from
the database myrouter.rrd and draw an area for the ``in'' traffic and a
line for the ``out'' traffic.


<P>

View the image and keep logging for a few more days. If you like, you could
try the examples from the test database and see if you can play around with
the options and calculations.


<P>

Suggestion:


<P>

Display in bytes per second and in bits per second. Make the ethernet
graphics go red if they are over four megabits per second.


<P>

<P>
<HR>
<H2><A NAME="Consolidation_Functions">Consolidation Functions

</A></H2>
A few paragraphs back I mentioned the possibility of keeping the maximum
values instead of the average values. Let's go into this a bit more.


<P>

Recall all the stuff about the speed of the car. Suppose we drove at 144
KM/H during 5 minutes and then were stopped by the police for 25 minutes.
At the end of the lecture we would take our laptop and create+view the
image taken from the database. If we look at the second RRA we did create,
we would have the average from 6 samples. The samples measured would be
144+0+0+0+0+0=144, divided by 30 minutes, corrected for the error by 1000,
translated into KM/H, with a result of 24 KM/H. I would still get a ticket
but not for speeding anymore :)


<P>

Obviously, in this case, we shouldn't look at the averages. In some cases
they are handy. If you want to know how much KM you had traveled, the
picture would be the right one to look at. On the other hand, for the speed
that we traveled at, the maximum number seen is much more valuable. (later
we will see more types)


<P>

It is the same for data. If you want to know the amount, look at the
averages. If you want to know the rate, look at the maximum. Over time,
they will grow apart more and more. In the last database we have created,
there are two archives that keep data per day. The archive that keeps
averages will show low numbers, the archive that shows maxima will have
higher numbers. For my car this would translate in averages per day of
96/24=4 KM/H (as I travel about 94 kilometers on a day) during week days,
and maximum of 120 KM/H on weekdays (my top speed that I reach every day).


<P>

Big difference. Do not look at the second graph to estimate the distances
that I travel and do not look at the first graph to estimate my speed. This
will work if the samples are close together, as they are in five minutes,
but not if you average.


<P>

On some days, I go for a long ride. If I go across Europe and travel for
over 12 hours, the first graph will rise to about 60 KM/H. The second one
will show 180 KM/H. This means that I traveled a distance of 60 KM/H times
24 H = 1440 KM. I did this with a higher speed and a maximum around 180
KM/H. This doesn't mean that I traveled for 8 hours at a constant speed of
180 KM/H ! This is a real example: go with the flow through Germany and
stop a few times for gas and coffee. Drive slowly through Austria and the
Netherlands. Be careful in the mountains and villages. If you would look at
the graphs created from the five-minute averages you would get a totally
different picture. You would see the same values on the average and maximum
graphs (provided I measured every 300 seconds). You would be able to see
when I stopped, when I was in top gear, when I drove over fast motor-ways
etc. The granularity of the data is much higher, so you can see more.
However, this takes 12 samples per hour, or 288 values per day, so it would
be too much to keep for a long period of time. Therefore we average it,
eventually to one value per day. From this one value, we cannot see much
detail.


<P>

Make sure you understand the last few paragraphs. There is no value in only
a line and a few axis, you need to know what they mean and interpret the
data in a good way. This is true for all data.


<P>

The biggest mistake you can make is to use the collected data for something
that it is not suitable for. You would be better off if you would not have
the graphics at all in that case.


<P>

<P>
<HR>
<H2><A NAME="Let_s_review_what_you_now_should">Let's review what you now should know.

</A></H2>
You now know how to create a database. You can put the numbers in it, get
them out again by creating an image, do math on the data from the database
and view the outcome instead of the raw data. You know about the difference
between averages and maxima, and when to use which (or at least you have an
idea).


<P>

RRDtool can do more than what we have learned up to now. Before you
continue with the rest of this doc, I recommend that you reread from the
start and try some modifications on the examples. Make sure you fully
understand everything. It will be worth the effort and helps you not only
with the rest of this doc but also in your day to day monitoring long after
you read this introduction.


<P>

<P>
<HR>
<H2><A NAME="Data_Source_Types">Data Source Types

</A></H2>
All right, you feel like continuing. Welcome back and get ready for an
increased speed in the examples and explanation.


<P>

You know that in order to view a counter over time, you have to take two
numbers and divide the difference of them between the time lapsed. This
makes sense for the examples I gave you but there are other possibilities.
For instance, I'm able to retrieve the temperature from my router in three
places namely the inlet, the so called hot-spot and the exhaust. If I take
the difference of the two samples and divide that by 300 (seconds) there
would not be very much to display ... If there would be anything to display
it would be the fluctuations in the temperature and if they produce
noticeable results when divided by 300, I'd better look for a new computer
room.


<P>

So, what can we do ? RRDtool can also store the values you measure directly
as they are (this is not entirely true but close enough). The graphs we
make look much better, they will show a rather constant value. I know when
the router is busy (it works -&gt; it uses more electricity -&gt; it
generates more heat -&gt; the temperature rises). I know when the doors are
left open (the room is cooled -&gt; the warm air from the rest of the
building flows into the computer room -&gt; the inlet temperature rises)
etc. The data type we use when creating the database before was counter, we
now have a different data type and thus a different name for it. It is
called GAUGE. There are more such data types:


<P>

<PRE> - COUNTER   we already know this one
 - GAUGE     we just learned this one
 - DERIVE
 - ABSOLUTE
</PRE>

<P>

The two new types are DERIVE and ABSOLUTE. Absolute can be used like
counter with one difference: RRDtool assumes the counter is reset when it's
read. That is: its delta is known without calculation by RRDtool whereas
RRDtool needs to calculate it for the counter type. Example: our first
example (12345, 12357, 12363, 12363) would read: unknown, 12, 6, 0. The
rest of the calculations stay the same. The other one, derive, is like
counter. Unlike counter, it can also decrease so it can have a negative
delta. Again, the rest of the calculations stay the same.


<P>

Let's try them all:


<P>

<PRE>   rrdtool create all.rrd --start 978300900 \
            DS:a:COUNTER:600:U:U \
            DS:b:GAUGE:600:U:U \
            DS:c:DERIVE:600:U:U \
            DS:d:ABSOLUTE:600:U:U \
            RRA:AVERAGE:0.5:1:10
   rrdtool update all.rrd \
            978301200:300:1:600:300    \
            978301500:600:3:1200:600   \
            978301800:900:5:1800:900   \
            978302100:1200:3:2400:1200 \
            978302400:1500:1:2400:1500 \
            978302700:1800:2:1800:1800 \
            978303000:2100:4:0:2100    \
            978303300:2400:6:600:2400  \
            978303600:2700:4:600:2700  \
            978303900:3000:2:1200:3000
   rrdtool graph all1.gif -s 978300600 -e 978304200 -h 400 \
            DEF:linea=all.rrd:a:AVERAGE LINE3:linea#FF0000:&quot;Line A&quot; \
            DEF:lineb=all.rrd:b:AVERAGE LINE3:lineb#00FF00:&quot;Line B&quot; \
            DEF:linec=all.rrd:c:AVERAGE LINE3:linec#0000FF:&quot;Line C&quot; \
            DEF:lined=all.rrd:d:AVERAGE LINE3:lined#000000:&quot;Line D&quot;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="RRD_Tool_under_the_Microscope">RRD Tool under the Microscope

</A></H2>
<UL>
<LI><STRONG></STRONG>
Line A is a counter so it should continuously increment and RRDtool should
calculate the differences. Also, RRDtool needs to divide the difference by
the amount of time lapsed. This should end up as a straight line at 1 (the
deltas are 300, the time is 300).


<P>

<LI><STRONG></STRONG>
Line B is of type gauge. These are ``real'' values so they should match
what we put in: a sort of a wave.


<P>

<LI><STRONG></STRONG>
Line C is derive. It should be a counter that can decrease. It does so
between 2400 and 0, with 1800 in-between.


<P>

<LI><STRONG></STRONG>
Line D is of type absolute. This is like counter but it works on values
without calculating the difference. The numbers are the same and as you can
see (hopefully) this has a different result.


<P>

</UL>
This translates in the following values, starting at 23:10 and ending at
00:10 the next day (where U means unknown/unplotted):


<P>

<PRE> - Line A:  u  u  1  1  1  1  1  1  1  1  1  u
 - Line B:  u  1  3  5  3  1  2  4  6  4  2  u
 - Line C:  u  u  2  2  2  0 -2 -6 -2  0  2  u
 - Line D:  u  1  2  3  4  5  6  7  8  9 10  u
</PRE>

<P>

If your GIF shows all this, you know you have typed the data correct, the
RRDtool executable is working properly, your viewer doesn't fool you and
you successfully entered the year 2000 :) You could try the same example
four times, each time with only one of the lines.


<P>

Let's go over the data again:


<P>

<UL>
<LI><STRONG></STRONG>
Line A: 300,600,900 and so on. The counter delta is a constant 300 and so
it the time delta. A number divided by itself is always 1 (except when
dividing by zero which is undefined/illegal). Why is it that the first
point is unknown ? We do know what we put into the database ? True ! But we
didn't have a value to calculate the delta from so we don't know where we
started. It would be wrong to assume we started at zero so we don't !


<P>

<LI><STRONG></STRONG>
Line B: There is nothing to calculate. The numbers are as is.


<P>

<LI><STRONG></STRONG>
Line C: Again, the start-out value is unknown. The same story is valid like
for line A. In this case the deltas are not constant so the line is not. If
we would put the same numbers in the database as we did for line A, we
would have gotten the same line. Unlike type counter, this type can
decrease and I hope to show you later on why there is a difference.


<P>

<LI><STRONG></STRONG>
Line D: Here the device calculates the deltas. Therefore we DO know the
first delta and it is plotted. We had the same input as with line A but the
meaning of this input is different. Therefore the line is different. In
this case the deltas increase each time with 300. The time delta stays at a
constant 300 and therefore the division of the two gives increasing
results.


<P>

</UL>
<P>
<HR>
<H2><A NAME="Counter_Wraps">Counter Wraps

</A></H2>
There are a few more basics to show. Some important options are still to be
covered and we haven't look at counter wraps yet. First the counter wrap:
In our car we notice that our counter shows 999987. We travel 20 KM and the
counter should go to 1000007. Unfortunately, there are only six digits on
our counter so it really shows 000007. If we would plot that on a type
DERIVE, it would mean that the counter was set back 999980 KM. It wasn't,
and there has to be some protection for this. This protection is only
available for type COUNTER which should be used for this kind of counter
anyways. How does it work ? Type counter should never decrease and
therefore RRDtool must assume it wrapped if it does decrease ! If the delta
is negative, this can be compensated for by adding the maximum value of the
counter + 1. For our car this would be:


<P>

<PRE> Delta = 7 - 999987 = -999980    (instead of 1000007-999987=20)
</PRE>

<P>

<PRE> Real delta = -999980 + 999999 + 1 = 20
</PRE>

<P>

At the moment of writing this document, RRDtool knows of counters that are
either 32 bits or 64 bits of size. These counters can handle the following
different values:


<P>

<PRE> - 32 bits: 0 ..           4294967295
 - 64 bits: 0 .. 18446744073709551615
</PRE>

<P>

If these numbers look strange to you, you would like to view them in their
hexadecimal form:


<P>

<PRE> - 32 bits: 0 ..         FFFFFFFF
 - 64 bits: 0 .. FFFFFFFFFFFFFFFF
</PRE>

<P>

RRDtool handles both counters the same. If an overflow occurs and the delta
would be negative, RRDtool first adds the maximum of a small counter + 1 to
the delta. If the delta is still negative, it had to be the large counter
that wrapped. Add the maximum possible value of the large counter + 1 and
subtract the falsely added small value. There is a risk in this: suppose
the large counter wrapped while adding a huge delta, it could happen in
theory that adding the smaller value would make the delta positive. In this
unlikely case the results would not be correct. The increase should be
nearly as high as the maximum counter value for that to happen so chances
are you would have several other problems as well and this particular
problem would not even be worth thinking about. Even though I did include
an example of it so you can judge that for yourself.


<P>

The next section gives you some numerical examples for counter-wraps. Try
to do the calculations yourself or just believe me if your calculator can't
handle the numbers :)


<P>

Correction numbers:


<P>

<PRE> - 32 bits: (4294967295+1) =                                 4294967296
 - 64 bits: (18446744073709551615+1)-correction1 = 18446744069414584320
</PRE>

<P>

<PRE> Before:        4294967200
 Increase:             100
 Should become: 4294967300
 But really is:          4
 Delta:        -4294967196
 Correction1:  -4294967196 +4294967296 = 100
</PRE>

<P>

<PRE> Before:        18446744073709551000
 Increase:                       800
 Should become: 18446744073709551800
 But really is:                  184
 Delta:        -18446744073709550816
 Correction1:  -18446744073709550816 +4294967296 = -18446744069414583520
 Correction2:  -18446744069414583520 +18446744069414584320 = 800
</PRE>

<P>

<PRE> Before:        18446744073709551615 ( maximum value )
 Increase:      18446744069414584320 ( absurd increase, minimum for
 Should become: 36893488143124135935             this example to work )
 But really is: 18446744069414584319
 Delta:                  -4294967296
 Correction1:  -4294967296 + 4294967296 = 0
 (not negative -&gt; no correction2)
</PRE>

<P>

<PRE> Before:        18446744073709551615 ( maximum value )
 Increase:      18446744069414584319 ( one less increase )
 Should become: 36893488143124135934
 But really is: 18446744069414584318
 Delta:                  -4294967297
 Correction1:  -4294967297 +4294967296 = -1
 Correction2:  -1 +18446744069414584320 = 18446744069414584319
</PRE>

<P>

As you can see from the last two examples, you need strange numbers for
RRDtool to fail (provided it's bug free of course) so this should not
happen. However, SNMP or whatever method you choose to collect the data
might also fail and it is not uncommon to get wrong numbers occasionally.
We can't prevent all errors but there are some things we could do. RRDtool
create takes two special parameters for this. They define the minimum and
maximum allowed value. Until now, we made them ``U'' for Unknown. You may
(not: must) provide values for one or both of them and if RRDtool receives
values that are outside these limits, it will ignore them. For a
thermometer in degrees Celsius, the absolute minimum is just under -273.
For my router, I can assume this minimum is much higher so I would say it
is 10. The maximum temperature for my router I would state as 80. Any
higher and the device would be out of order. For my car, I would never
expect negative numbers and also I would not expect numbers to be higher
than 230. Anything else, and there must have been an error. Remember: the
opposite is not true, if the numbers pass this check it doesn't mean that
they are correct. Always judge the graph with a healthy dose of paranoia if
it looks weird.


<P>

<P>
<HR>
<H2><A NAME="Data_Resampling">Data Resampling

</A></H2>
One important feature of RRDtool has not been explained yet: It is
virtually impossible to collect the data and feed it into RRDtool on exact
intervals. RRDtool therefore interpolates the data so it is on exact
intervals. If you do not know what this means or how it works, then here's
the help you seek:


<P>

Suppose a counter increases with exactly one for every second. You want to
measure it in 300 seconds intervals. You should retrieve values that are
exactly 300 apart. However, due to various circumstances you are a few
seconds late and the interval is 303. The delta will also be 303 in that
case. Obviously RRDtool should not put 303 in the database and make you
believe that the counter increased 303 in 300 seconds. This is where
RRDtool interpolates: it alters the 303 value as if it would have been
stored earlier and it will be 300 in 300 seconds. Next time you are at
exactly the right time. This means that the current interval is 297 seconds
and also the counter increased with 297. Again RRDtool alters the value and
stores 300 as it should be.


<P>

<PRE>      in the RDD                 in real
</PRE>

<P>

<PRE> time+000:   0 delta=&quot;U&quot;   time+000:    0 delta=&quot;U&quot;
 time+300: 300 delta=300   time+300:  300 delta=300
 time+600: 600 delta=300   time+603:  603 delta=303
 time+900: 900 delta=300   time+900:  900 delta=297
</PRE>

<P>

Let's create two identical databases. I've chosen the time range 920805000
to 920805900 as this goes very well with the example numbers.


<P>

<PRE>   rrdtool create seconds1.rrd   \
      --start 920804700          \
      DS:seconds:COUNTER:600:U:U \
      RRA:AVERAGE:0.5:1:24
</PRE>

<P>

<PRE>   for Unix: cp seconds1.rrd seconds2.rrd
   for Dos:  copy seconds1.rrd seconds2.rrd
   for vms:  how would I know :)
</PRE>

<P>

<PRE>   rrdtool update seconds1.rrd \
      920805000:000 920805300:300 920805600:600 920805900:900
   rrdtool update seconds2.rrd \
      920805000:000 920805300:300 920805603:603 920805900:900
</PRE>

<P>

<PRE>   rrdtool graph seconds1.gif                       \
      --start 920804700 --end 920806200             \
      --height 200                                  \
      --upper-limit 1.05 --lower-limit 0.95 --rigid \
      DEF:seconds=seconds1.rrd:seconds:AVERAGE      \
      CDEF:unknown=seconds,UN                       \
      LINE2:seconds#0000FF                          \
      AREA:unknown#FF0000
   rrdtool graph seconds2.gif                       \
      --start 920804700 --end 920806200             \
      --height 200                                  \
      --upper-limit 1.05 --lower-limit 0.95 --rigid \
      DEF:seconds=seconds2.rrd:seconds:AVERAGE      \
      CDEF:unknown=seconds,UN                       \
      LINE2:seconds#0000FF                          \
      AREA:unknown#FF0000
</PRE>

<P>

Both graphs should show the same.


<P>

<P>
<HR>
<H1><A NAME="WRAPUP">WRAPUP

</A></H1>
It's time to wrap up this document. You now know all the basics to be able
to work with RRDtool and to read the documentation available. There is
plenty more to discover about RRDtool and you will find more and more uses
for the program. You could create easy graphics using just the examples
provided and using only RRDtool. You could also use the front ends that are
available.


<P>

<P>
<HR>
<H1><A NAME="MAILINGLIST">MAILINGLIST

</A></H1>
Remember to subscribe to the mailing-list. Even if you are not answering
the mails that come by, it helps both you and the rest. A lot of the stuff
that I know about MRTG (and therefore about RRDtool) I've learned while
just reading the list without posting to it. I did not need to ask the
basic questions as they are answered in the FAQ (so: read that too) and in
various mails by other users. With thousands of users all over the world,
there will always be people who ask questions that you can answer because
you read this and other documentation and they didn't.


<P>

<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO

</A></H1>
The RRD Tool manpages


<P>

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR

</A></H1>
I hope you enjoyed the examples and their descriptions. If you do, help
other people by pointing them to this document when they are asking basic
questions. They will not only get their answer but at the same time learn a
whole lot more.


<P>

Alex van den Bogaerdt <A
HREF="MAILTO:<alex@ergens.op.het.net>"><alex@ergens.op.het.net></A>


<P>

</DL>
    </BODY>

    </HTML>
