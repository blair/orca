RRDTUTORIAL.ES(1)            RRDtool            RRDTUTORIAL.ES(1)



NNAAMMEE
       rrdtutorial - Tutorial sobre RRDtool por Alex van den
       Bogaerdt (Traducido al castellano por Jes'us Couto Fandi~no)

DDEESSCCRRIIPPTTIIOONN
       RRDtool es un programa escrito por Tobias Oetiker con la
       colaboraci'on de muchas personas en diversas partes del
       mundo. Alex van den Bogaerdt escribi'o este documento para
       ayudarte a entender que es RRDtool y que es lo que puede
       hacer por ti.

       La documentaci'on que viene con RRDtool puede ser demasiado
       t'ecnica para algunos. Este tutorial existe para ayudarte a
       entender las funciones b'asicas de RRdtool. Debe servirte
       de preparaci'on para leer la documentaci'on, y adem'as
       explica algunas ideas generales sobre estad'istica, con un
       enfoque particular hacia las redes.

TTUUTTOORRIIAALL
       IImmppoorrttaannttee

       ,iPor favor, no te adelantes en la lectura de este docu-
       mento! Esta primera parte explica los fundamentos b'asicos.
       Puede ser aburrida, pero si te saltas los fundamentos, los
       ejemplos no te van a tener mucho sentido.

       ''ccQQuu''ee eess RRRRDDttooooll??

       RRDtool significa "herramienta de bases de datos en round
       robin".  "Round robin" es una t'ecnica que implica un
       n'umero fijo de datos, y un apuntador al elemento m'as
       reciente. Piensa en un circulo con unos cuantos puntos
       dibujados alrededor del borde; estos puntos son los
       lugares donde se pueden guardar los datos. Dibuja ahora
       una flecha desde el centro del c'irculo a uno de los pun-
       tos; este es el apuntador.  Cuando se lee o escribe el
       dato actualmente apuntado, la flecha se mueve al pr'oximo
       elemento. Como estamos en un c'irculo, no hay ni principio
       ni fin; siempre puedes seguir, eternamente. Al cabo de un
       tiempo ya se habr'an usado todas las posiciones disponibles
       y el proceso empieza a reutilizar las antiguas. De esta
       forma, la base de datos no crece en tama~no y, por lo
       tanto, no requiere ning'un mantenimiento.  RRDtool trabaja
       con estas bases de datos en "round-robin", guardando y
       recuperando datos de ellas.

       ''ccQQuu''ee ddaattooss ppuueeddeenn gguuaarrddaarrssee eenn uunnaa RRRRDD??

       Lo que se te ocurra. Debes poder medir alg'un valor dado en
       distintos momentos en el tiempo y proveer a RRDtool de
       estos valores. Si puedes hacer esto, RRDtool puede guardar
       los datos. Los valores tienen que ser num'ericos, pero no
       necesariamente enteros, como en MRTG.

       Muchos ejemplos mencionan SNMP, que es el acr'onimo de
       "Simple Network Management Protocol" (Protocolo Simple de
       Administraci'on de Redes). Lo de "simple" se refiere al
       protocolo - no se supone que sea f'acil administrar o moni-
       torizar una red. Cuando hayas terminado con este docu-
       mento, deber'as saber lo suficiente para entender cuando
       oigas a otros hablar sobre SNMP. Por ahora, simplemente
       considera a SNMP como una forma de preguntarle a los
       dispositivos por los valores de ciertos contadores que
       mantienen. Son estos valores de estos contadores los que
       vamos a almacenar en la RRD.

       ''ccQQuu''ee ppuueeddoo hhaacceerr ccoonn eessttaa hheerrrraammiieennttaa??

       RRDtool se deriva de MRTG (Multi Router Traffic Grapher,
       Graficador De Tr'afico de M'ultiples Enrutadores).  MRTG
       empez'o como un peque~no script para poder graficar el uso
       de una conexi'on a la Internet. Luego evolucion'o, permi-
       tiendo graficar otras fuentes de datos, como temperatura,
       velocidad, voltajes, cantidad de p'aginas impresas, etc...
       Lo m'as probable es que empieces a usar RRDtool para
       guardar y procesar datos conseguidos a trav'es de SNMP, y
       que los datos sean el n'umero de bytes (o bits) transferi-
       dos desde y hacia una red u ordenador. RRDtool te permite
       crear una base de datos, guardar los datos en ellas, recu-
       perarlos y crear gr'aficos en formato GIF o PNG, para
       mostrarlos en un navegador web. Esas im'agenes dependen de
       los datos que hayas guardado y pueden, por ejemplo, ser un
       sumario del promedio de uso de la red, o los picos de
       tr'afico que ocurrieron.  Tambi'en lo puedes usar para
       mostrar el nivel de las mareas, la radiaci'on solar, el
       consumo de electricidad, el n'umero de visitantes en una
       exposici'on en un momento dado, los niveles de ruido cerca
       del aeropuerto, la temperatura en tu lugar de vacaciones
       favorito, o en la nevera, o cualquier otra cosa que te
       puedas imaginar, mientras tengas alg'un sensor con el cual
       medir los datos y seas capaz de pasarle los n'umeros a RRD-
       tool.

       ''ccYY ssii aa''uunn tteennggoo pprroobblleemmaass ddeessppuu''eess ddee lleeeerr eessttee ddooccuummeennttoo??

       Lo primero, ,il'eelo otra vez!. Puede que te hayas perdido
       de algo.  Si no puedes compilar el c'odigo fuente y usas un
       sistema operativo bastante com'un, casi seguro que no es la
       culpa de RRDtool.  Probablemente consigas versiones pre-
       compiladas por la Internet. Si provienen de una fuente
       confiable, 'usalas. Si, por otro lado, el programa fun-
       ciona, pero no te da los resultados que tu esperabas,
       puede ser un problema con la configuraci'on; rev'isala y
       comp'arala con los ejemplos.

       Hay una lista de correo electr'onico y una archivo de la
       misma. Lee la lista durante unas cuantas semanas, y busca
       en el archivo. Es descort'es hacer una pregunta sin haber
       revisado el archivo; ,ipuede que tu problema ya haya sido
       resuelto antes! Normalmente ocurre as'i en todas las listas
       de correo, no s'olo esta. Examina la documentaci'on que vino
       con RRDtool para ver donde est'a el archivo y como usarlo.

       Te sugiero que te tomes un momento y te subscribas a la
       lista ahora mismo, enviando un mensaje a
       rrd-users-request@list.ee.ethz.ch con t'itulo "subscribe".
       Si eventualmente deseas salirte de la lista, env'ia otro
       correo a la misma direcci'on, con t'itulo "unsubscribe".

       ''ccCC''oommoo mmee vvaass aa aayyuuddaarr??

       D'andote descripciones y ejemplos detallados. Asumimos que
       el seguir las instrucciones en el orden en que se presen-
       tan aqu'i te dar'a suficiente conocimiento  de RRDtool como
       para que experimentes por tu cuenta. Si no funciona a la
       primera, puede que te hallas saltado algo; siguiendo los
       ejemplos obtendr'as algo de experiencia pr'actica y, lo que
       es m'as importante, un poco de informaci'on sobre como
       funciona el programa.

       Necesitar'as saber algo sobre n'umeros hexadecimales. Si no,
       empieza por leer "bin_dec_hex" antes de continuar.

       TTuu pprriimmeerraa bbaassee ddee ddaattooss eenn rroouunndd--rroobbiinn

       En mi opini'on, la mejor forma de aprender algo es
       haci'endolo. 'cPor qu'e no empezamos ya? Vamos a crear una
       base de datos, poner unos cuantos valores en ella y
       extraerlos despu'es. La salida que obtengas debe ser igual
       a la que aparece en este documento.

       Empezaremos con algo f'acil, comparando un coche con un
       enrutador, o por decirlo de otra forma, comparando
       kil'ometros con bits y bytes. A nosotros nos da lo mismo;
       son unos n'umeros obtenidos en un espacio de tiempo.

       Asumamos que tenemos un dispositivo que transfiere bytes
       desde y hacia la Internet. Este dispositivo tiene un con-
       tador que empieza en 0 al encenderse y se incrementa con
       cada byte transferido. Este contador tiene un valor
       m'aximo; si ese valor se alcanza y se cuenta un byte m'as,
       el contador vuelve a empezar desde cero. Esto es exacta-
       mente lo mismo que pasa con muchos contadores, como el
       cuentakil'ometros del coche. En muchas de las disertaciones
       sobre redes se habla de bits por segundo, as'i que
       empezaremos por acostumbrarnos a esto. Asumamos que un
       byte son 8 bits y empecemos a pensar en bits y no en
       bytes. ,iEl contador, sin embargo, sigue contando en bytes!
       En el mundo SNMP, la mayor'ia de los contadores tienen una
       longitud de 32 bits. Esto significa que pueden contar
       desde 0 hasta 4294967295. Usaremos estos valores en los
       ejemplos. El dispositivo, cuando le preguntamos, retorna
       el valor actual del contador. Como sabemos el tiempo tran-
       scurrido desde la 'ultima vez que le preguntamos, sabemos
       cuantos bytes se han transferido "***en promedio***" por
       segundo. Esto no es muy dif'icil de calcular; primero en
       palabras, luego en operaciones:

       1.  Toma el valor actual del contador y r'estale el valor
           anterior

       2.  Haz lo mismo con la fecha

       3.  Divide el resultado del paso (1) por el resultado del
           paso (2).  El resultado es la cantidad de bytes por
           segundo. Si lo multiplicas por ocho obtienes la canti-
           dad de bits por segundo

         bps = (contador_actual - contador_anterior) / (fecha_actual - fecha_anterior) * 8

       Para algunos ser'a de ayuda traducir esto a un ejemplo
       automotor.  No prueben estas velocidades en la pr'actica, y
       si lo hacen, no me echen la culpa por los resultados.

       Usaremos las siguientes abreviaturas:

        M:    metros
        KM:   kil'ometros (= 1000 metros).
        H:    horas
        S:    segundos
        KM/H: kil'ometros por hora
        M/S:  metros por segundo

       Vas conduciendo un coche. A las 12:05, miras el contador
       en el salpicadero y ves que el coche ha recorrido 12345
       KM. A las 12:10 vuelves a mirar otra vez, y dice 12357 KM.
       Quiere decir, que has recorrido 12 KM en cinco minutos. Un
       cient'ifico convertir'ia esto en metros por segundos; esto
       es bastante parecido al problema de pasar de bytes trans-
       feridos en 5 minutos a bits por segundo.

       Viajamos 12 kil'ometros, que son 12000 metros. Tardamos 5
       minutos, o sea 300 segundos. Nuestra velocidad es 12000M /
       300S igual a 40 M/S.

       Tambi'en podemos calcular la velocidad en KM/H: 12 veces 5
       minutos es una hora, as'i que multiplicando los 12 KM por
       12 obtenemos 144 KM/H. No intentes esto en casa, o por
       donde vivo :-)

       Recuerda que estos n'umeros son tan s'olo promedios. No hay
       forma de deducir, viendo s'olo los n'umeros, si fuiste a una
       velocidad constante.  Hay un ejemplo m'as adelante en el
       tutorial que explica esto.

       Espero que entiendas que no hay diferencia entre calcular
       la velocidad en M/S o bps; s'olo la forma en que recogemos
       los datos es distinta. Inclusive, la K de kilo en este
       caso es exactamente la misma, ya que en redes k es 1000

       Ahora vamos a crear una base de datos en la que guardar
       todos estos interesantes valores. El m'etodo a usar para
       arrancar el programa puede variar de un sistema de
       operaci'on a otro, pero asumamos que lo puedes resolver tu
       mismo en caso que se diferente en el sistema que usas.
       Aseg'urate de no sobreescribir ning'un archivo en tu sistema
       al ejecutarlo y escribe todo como una sola l'inea (tuve que
       partirlo para que fuera legible), salt'andote todos los
       caracteres '\'

          rrdtool create test.rrd             \
                   --start 920804400          \
                   DS:speed:COUNTER:600:U:U   \
                   RRA:AVERAGE:0.5:1:24       \
                   RRA:AVERAGE:0.5:6:10

       (o sea, escribe: "rrdtool create test.rrd --start
       920804400 DS ...")

       ''ccQQuu''ee hheemmooss ccrreeaaddoo??

       Hemos creado una base de datos en round robin llamada test
       (test.rrd), que empieza desde el mediod'ia del d'ia en que
       empec'e a escribir este documento (7 de marzo de 1999). En
       ella se guarda una fuente de datos (DS), llamada "speed",
       que se lee de un contador. En la misma base de datos se
       guardan dos archivos en round robin (RRAs), uno promedia
       los datos cada vez que se leen (o sea, no hay nada que
       promediar), y mantiene 24 muestras (24 por 5 minutos = 2
       horas de muestras). El otro promedia 6 muestras (media
       hora), y guarda 10 de estos promedios (o sea, 5 horas).
       Las opciones restantes las veremos m'as adelante.

       RRDtool usa un formato de "fecha" especial que viene del
       mundo de UNIX. Estas "fechas" son el n'umero de segundos
       que han pasado desde el primero de enero de 1970, zona
       UTC. Este n'umero de segundos se convierte luego en la
       fecha local, por lo que varia seg'un la franja horaria.

       Lo m'as probable es que tu no vivas en la misma parte del
       mundo que yo, por lo que tu franja horaria ser'a diferente.
       En los ejemplos, cuando mencione horas, puede que no sean
       las mismas para ti; esto no afecta mucho los resultados,
       s'olo tienes que corregir las horas mientras lees. Por
       ejemplo, las 12:05 para m'i son las 11:05 para los amigos
       en la Gran Breta~na.

       Ahora tenemos que llenar nuestra base de datos con val-
       ores. Vamos a suponer que le'imos estos datos:

        12:05  12345 KM
        12:10  12357 KM
        12:15  12363 KM
        12:20  12363 KM
        12:25  12363 KM
        12:30  12373 KM
        12:35  12383 KM
        12:40  12393 KM
        12:45  12399 KM
        12:50  12405 KM
        12:55  12411 KM
        13:00  12415 KM
        13:05  12420 KM
        13:10  12422 KM
        13:15  12423 KM

       Llenaremos la base de datos as'i:

        rrdtool update test.rrd 920804700:12345 920805000:12357 920805300:12363
        rrdtool update test.rrd 920805600:12363 920805900:12363 920806200:12373
        rrdtool update test.rrd 920806500:12383 920806800:12393 920807100:12399
        rrdtool update test.rrd 920807400:12405 920807700:12411 920808000:12415
        rrdtool update test.rrd 920808300:12420 920808600:12422 920808900:12423

       Lo que significa: actualiza nuestra base de datos test con
       los siguientes valores:

        fecha 920804700, valor 12345
        fecha 920805000, valor 12357

        etc'etera.

       Como ves, pueden introducirse m'as de un valor en la base
       de datos por ejecuci'on del comando. Yo los agrupo de tres
       en tres para hacerlo legible, pero en realidad el m'aximo
       depende del sistema de operaci'on.

       Ahora podemos recuperar los datos usando ``rrdtool
       fetch'':

        rrdtool fetch test.rrd AVERAGE --start 920804400 --end 920809200

       Debes obtener esto como salida:

                           speed











        920804400:        NaN
        920804700:        NaN
        920805000: 4.0000000000e-02
        920805300: 2.0000000000e-02
        920805600: 0.0000000000e+00
        920805900: 0.0000000000e+00
        920806200: 3.3333333333e-02
        920806500: 3.3333333333e-02
        920806800: 3.3333333333e-02
        920807100: 2.0000000000e-02
        920807400: 2.0000000000e-02
        920807700: 2.0000000000e-02
        920808000: 1.3333333333e-02
        920808300: 1.6666666667e-02
        920808600: 6.6666666667e-03
        920808900: 3.3333333333e-03
        920809200:        NaN

       Si no, hay algo mal. Probablemente tu sistema de operaci'on
       muestre ``NaN'' de otra forma; representa "Not a Number",
       o sea "No es un n'umero". Si aparece ``U'' o ``UNKN'' o
       algo parecido, es lo mismo. Si hay alguna otra diferencia,
       probablemente te equivocaste al introducir alg'un P valor
       (asumiendo que mi tutorial est'a bien, por supuesto :-). En
       ese caso, borra la base de datos y prueba de nuevo.

       Lo que representa exactamente esta salida lo vamos m'as
       adelante en el tutorial.

       HHoorraa ddee hhaacceerr aallgguunnooss ggrr''aaffiiccooss

       Prueba este comando:

        rrdtool graph speed.gif                                 \
                --start 920804400 --end 920808000               \
                DEF:myspeed=test.rrd:speed:AVERAGE              \
                LINE2:myspeed#FF0000

       Este comando crea speed.gif, un gr'afico de los datos desde
       las 12:00 hasta las 13:00. Contiene una definici'on de la
       variable myspeed y define el color como rojo. Notar'as que
       el gr'afico no comienza exactamente a las 12:00 sino a las
       12:05, y es porque no tenemos datos suficientes como para
       calcular el promedio de velocidad antes de ese momento.
       Esto s'olo ocurre en caso de que se pierdan alg'un muestreo,
       lo que esperamos que no debe ocurrir muy a menudo.

       Si ha funcionado, ,ifelicitaciones!. Si no, revisa qu'e
       puede estar mal.

       La definici'on de colores se construye a partir del rojo,
       verde y azul. Especificas cuanto de cada uno de estos com-
       ponentes vas a usar en hexadecimal: 00 significa "nada de
       este color" y FF significa "este color a m'axima intensi-
       dad". El "color" blanco es la mezcla del rojo, verde y
       azul a toda intensidad: FFFFFF; el negro es la ausencia de
       todos los colores: 000000.

          rojo    #FF0000
          verde   #00FF00
          azul    #0000FF
          violeta #FF00FF     (mezcla de rojo y azul)
          gris    #555555     (un tercio de cada uno de los colores)

       El archivo GIF que acabas de crear puede verse con tu
       visor de archivos de imagen favorito. Los navegadores lo
       mostrar'an usando la URL ``file://el/camino/de/directo-
       rios/hasta/speed.gif''

       GGrr''aaffiiccooss ccoonn uunn ppooccoo ddee mmaatteemm''aattiiccaa

       Cuando veas la imagen, notar'as que el eje horizontal tiene
       unas etiquetas marcando las 12:10, 12:20, 12:30, 12:40 y
       12:50. Los otros dos momentos (12:00 y 13:00) no se pueden
       mostrar bien por falta de datos, as'i que el programa se
       los salta. El eje vertical muestra el rango de los valores
       que entramos. Introdujimos los kil'ometros y luego dividi-
       mos entre 300 segundos, por lo que obtuvimos valores bas-
       tante bajos. Para ser exactos, el primer valor, 12
       (12357-12345), dividido entre 300 da 0.04, lo que RRDtool
       muestra como ``40m'', o sea ``40/1000''. ,iLa ``m''' no
       tiene nada que ver con metros, kil'ometros o mil'imetros!.
       RRDtool no sabe nada de unidades, el s'olo trabaja con
       n'umeros, no con metros.

       Donde nos equivocamos fue en que debimos medir en metros.
       As'i, (12357000-12345000)/300 = 12000/300 = 40.

       Vamos a corregirlo. Podr'iamos recrear la base de datos con
       los valores correctos, pero hay una forma mejor: ,ihaciendo
       los c'alculos mientras creamos el archivo gif!

          rrdtool graph speed2.gif                           \
             --start 920804400 --end 920808000               \
             --vertical-label m/s                            \
             DEF:myspeed=test.rrd:speed:AVERAGE              \
             CDEF:realspeed=myspeed,1000,*                   \
             LINE2:realspeed#FF0000

       Cuando veas esta imagen, notar'as que la ``m'' ha desapare-
       cido, y ahora tienes los resultados correctos. Adem'as
       hemos a~nadido una etiqueta a la imagen. Apartando esto, el
       archivo GIF es el mismo.

       Las operaciones est'an en la secci'on del CDEF y est'an
       escritas en Notaci'on Polaca Inversa (Reverse Polish Nota-
       tion o ``RPN''). En palabras, dice: "toma la fuente de
       datos myspeed y el numero 1000, y multipl'icalos". No te
       molestes en meterte con RPN todav'ia, la veremos con m'as
       detalle m'as adelante. Adem'as, puede que quieras leer mi
       tutorial sobre los CDEF y el tutorial de Steve Rader sobre
       RPN, pero primero terminemos con este.

       ,iUn momento! Si podemos multiplicar los valores por mil,
       entonces, ,itambi'en deber'ia ser posible el mostrar la
       velocidad en kil'ometros por hora usando los mismos datos!

       Para cambiar el valor que medimos en metros por segundo,
       calculamos los metros por hora (valor * 3600) y dividimos
       entre 1000 para sacar los kil'ometros por hora. Todo junto
       hace valor * (3600/1000) == valor * 3.6.

       Como en nuestra base de datos cometimos un error guardando
       los valores en kil'ometros, debemos compensar por ello,
       multiplicando por 100, por lo que al aplicar esta cor-
       recci'on nos queda valor * 3600.

       Ahora vamos a crear este gif, agre'andole un poco m'as de
       magia...



          rrdtool graph speed3.gif                           \
             --start 920804400 --end 920808000               \
             --vertical-label km/h                           \
             DEF:myspeed=test.rrd:speed:AVERAGE              \
             "CDEF:kmh=myspeed,3600,*"                       \
             CDEF:fast=kmh,100,GT,kmh,0,IF                   \
             CDEF:good=kmh,100,GT,0,kmh,IF                   \
             HRULE:100#0000FF:"Maximum allowed"              \
             AREA:good#00FF00:"Good speed"                   \
             AREA:fast#FF0000:"Too fast"

       Esto luce mucho mejor. La velocidad en KM/H, y adem'as ten-
       emos una l'inea extra mostrando la velocidad m'axima permi-
       tida (en el camino por donde conduzco). Tambi'en le cambie
       los colores de la velocidad, y ahora paso de ser una l'inea
       a un 'area.

       Los c'alculos son m'as complejos ahora. Para calcular la
       velocidad "aceptable":

          Verifica si la velocidad en kmh es mayor que 100     ( kmh,100 ) GT
          Si es as'i, retorna 0, si no, retorna la velocidad    ((( kmh,100 ) GT ), 0, kmh) IF

       Para calcular la parte de velocidad "excesiva":

          Verifica si la velocidad en kmh es mayor que 100     ( kmh,100 ) GT
          Si es as'i, retorna la velocidad, si no, retorna 0    ((( kmh,100) GT ), kmh, 0) IF

       MMaaggiiaa ggrr''aaffiiccaa

       Me gusta creer que virtualmente no hay limites para lo que
       RRDtool puede hacer con los datos. No voy a explicarlo en
       detalle, pero mira este GIF:

          rrdtool graph speed4.gif                           \
             --start 920804400 --end 920808000               \
             --vertical-label km/h                           \
             DEF:myspeed=test.rrd:speed:AVERAGE              \
             "CDEF:kmh=myspeed,3600,*"                       \
             CDEF:fast=kmh,100,GT,100,0,IF                   \
             CDEF:over=kmh,100,GT,kmh,100,-,0,IF             \
             CDEF:good=kmh,100,GT,0,kmh,IF                   \
             HRULE:100#0000FF:"Maximum allowed"              \
             AREA:good#00FF00:"Good speed"                   \
             AREA:fast#550000:"Too fast"                     \
             STACK:over#FF0000:"Over speed"

       Vamos a crear una p'agina HTML simple para ver los tres
       archivos GIF:

          <HTML><HEAD><TITLE>Velocidad</TITLE></HEAD><BODY>
          <IMG src="speed2.gif" alt="Speed in meters per second">
          <BR>
          <IMG src="speed3.gif" alt="Speed in kilometers per hour">
          <BR>
          <IMG src="speed4.gif" alt="Traveled too fast?">
          </BODY></HTML>

       Gu'ardalo como ``speed.html'' o algo parecido, y exam'inalo
       con un navegador.

       Ahora, todo lo que tienes que hacer es medir los datos
       regularmente y actualizar la base de datos. Cuando quieras
       verlos, vuelve a crear los archivos GIF y aseg'urate que se
       carguen de nuevo en tu navegador (Nota: presionar el bot'on
       de "refrescar" puede no ser suficiente; en particular,
       Netscape tiene un problema al respecto, por lo que necesi-
       taras darle al bot'on mientras presionas la tecla de
       may'usculas.

       AAccttuuaalliizzaacciioonneess ddee vveerrddaadd

       Ya hemos usado el comando ``update''; vimos que recibia
       uno o m'as par'ametros en el formato: ``<fecha>:<valor>''.
       Para facilitarte las cosas, puedes obtener la fecha actual
       colocando ``N'' en la fecha. Tambi'en podr'ias usar la
       funci'on ``time'' de Perl para obtenerla. El ejemplo m'as
       corto de todo el tutorial :)

          perl -e 'print time, "\n" '

       Ahora, la forma de poner a correr un programa a intervalos
       regulares de tiempo depende del sistema de operaci'on. La
       actualizaci'on, en pseudo-c'odigo, ser'ia:

          Toma el valor, col'ocalo en la variable "$speed"
          rrdtool update speed.rrd N:$speed

       (Pero no lo hagas sobre nuestra base de datos de pruebas,
       que a'un la vamos a usar en otros ejemplos.

       Eso es todo. Ejecutando este script cada 5 minutos, lo
       'unico que tienes que hacer para ver los gr'aficos actuales
       es correr los ejemplos anteriores, que tambi'en puedes
       poner en un script. Luego de correrlo, basta con cargar
       index.html

       UUnnaass ppaallaabbrraass ssoobbrree SSNNMMPP

       Me imagino que muy pocas personas ser'an capaces de obtener
       en su ordenador datos reales de su coche cada 5 minutos;
       los dem'as nos tendremos que conformar con alg'un otro con-
       tador. Puedes, por ejemplo, medir la cantidad de p'aginas
       que ha hecho una impresora, cuanto caf'e has hecho con la
       cafetera, el medidor del consumo de electricidad, o
       cualquier otra cosa. Cualquier contador incremental puede
       monitorizarse y graficarse con lo que has aprendido hasta
       ahora. M'as adelante, veremos tambi'en como monitorizar otro
       tipo de valores, como la temperatura. La mayor'ia usaremos
       alguna vez un contador que lleve la cuenta de cuantos
       octetos (bytes) a transferido un dispositivo de red, as'i
       que vamos a ver como hacer esto. Empezaremos describiendo
       como recoger los datos. Hay quien dir'a que hay herramien-
       tas que pueden recoger estos datos por ti. ,iEs cierto!
       Pero, creo que es importante darse cuenta de que no son
       necesarias. Cuando tienes que determinar porqu'e algo no
       funciona, necesitas saber c'omo funciona en primer lugar.

       Una herramienta que mencionamos brevemente al principio
       del documento es SNMP. SNMP es una forma de comunicarse
       con tus equipos.  La herramienta particular que voy a usar
       m'as adelante se llama ``snmpget'', y funciona as'i:

          snmpget dispositivo clave OID

       En "dispositivo" colocas el nombre o direcci'on IP del
       equipo a monitorizar. En clave, colocas la "cadena de car-
       acteres de la comunidad de lectura", como se le denomina
       en el mundillo SNMP.  Muchos dispositivos aceptar'an "pub-
       lic" como cadena por defecto, pero por razones de privaci-
       dad y seguridad esta clave puede estar deshabilitada. Con-
       sulta la documentaci'on correspondiente al dispositivo o
       programa.

       Luego esta el tercer par'ametro, llamado OID (Object IDen-
       tifier, identificador de objeto).

       Al principio, cuando empiezas a aprender sobre SNMP,
       parece muy confuso. No lo es tanto cuando le hechas una
       ojeada a los ``MIB'' (Manager Information Base, o Base de
       Informaci'on Administrativa). Es un 'arbol invertido que
       describe los datos, empezando en un nodo ra'iz desde el que
       parten varias ramas.  Cada rama termina en otro nodo y
       puede abrir nuevas sub-ramas. Cada rama tiene un nombre, y
       forman un camino que nos lleva hasta el fondo del 'arbol.
       En este ejemplo, las ramas que vamos a tomar se llaman
       iso, org, dod, internet, mgmt y mib-2. Tambi'en pueden
       accederse por su n'umero relativo; en este caso, estos
       n'umeros son 1, 3, 6, 1, 2 y 1:

          iso.org.dod.internet.mgmt.mib-2 (1.3.6.1.2.1)

       En algunos programas se usa un punto al iniciar el OID.
       Esto puede ser confuso; no hay ning'un punto inicial en la
       especificaci'on de los OID... sin embargo, algunos progra-
       mas usan por defecto un prefijo inicial. Para indicar la
       diferencia entre los OID abreviados (o sea, a los que se
       le pondr'a el prefijo inicial) y los completos, estos pro-
       gramas necesitan que los OID completos empiecen por un
       punto. Para empeorar las cosas, se usan varios prefijos
       distintos...

       De acuerdo, sigamos con el inicio de nuestro OID: ten'iamos
       1.3.6.1.2.1 . Ahora, nos interesa la rama ``interfaces'',
       que tiene el n'umero dos (o sea, 1.3.6.1.2.1.2, o
       1.3.6.1.2.1.interfaces).

       Lo primero es hacernos con un programa SNMP. Busca alg'un
       paquete pre-compilado para tu plataforma, si no, puedes
       buscar el c'odigo fuente y compilarlo tu mismo. En Internet
       encontrar'as muchos programas, b'uscalos con un motor de
       b'usqueda o como prefieras.  Mi sugerencia es que busques
       el paquete CMU-SNMP, que esta bastante difundido.

       Asumamos que ya tienes el programa. Empecemos por tomar
       ciertos datos que est'an disponibles en la mayor'ia de los
       sistemas. Recuerda: hay un nombre abreviado para la parte
       del 'arbol que m'as nos interesa.

       Voy a usar la versi'on corta, ya que creo que este docu-
       mento ya es lo bastante largo. Si no te funciona, a~n'adele
       el prefijo .1.3.6.1.2.1 y prueba de nuevo. O prueba
       leyendo el manual; s'altate las partes que no entiendas
       a'un, y busca las secciones que hablan de como arrancar y
       usar el programa.

          snmpget myrouter public system.sysdescr.0

       El dispositivo deber'a contestarte con una descripci'on,
       probablemente vac'ia, de s'i mismo. Si no consigues una
       respuesta v'alida, prueba con otra "clave" u otro disposi-
       tivo; no podemos seguir hasta tener un resultado.

          snmpget myrouter public interfaces.ifnumber.0

       Con suerte, usando este comando obtendr'as un n'umero como
       resultado: el n'umero de interfaces del dispositivo. Si es
       as'i, seguiremos adelante con otro programa, llamado
       "snmpwalk"

          snmpwalk myrouter public interfaces.iftable.ifentry.ifdescr

       Si obtienes una lista de interfaces, ya casi hemos lle-
       gado. Aqu'i tienes un ejemplo del resultado:

          [user@host /home/alex]$ snmpwalk cisco public 2.2.1.2
          interfaces.ifTable.ifEntry.ifDescr.1 = "BRI0: B-Channel 1"
          interfaces.ifTable.ifEntry.ifDescr.2 = "BRI0: B-Channel 2"
          interfaces.ifTable.ifEntry.ifDescr.3 = "BRI0" Hex: 42 52 49 30
          interfaces.ifTable.ifEntry.ifDescr.4 = "Ethernet0"
          interfaces.ifTable.ifEntry.ifDescr.5 = "Loopback0"

       En este equipo CISCO, quiero monitorizar la interfaz "Eth-
       ernet0".  Viendo que es la cuarta, pruebo con:

          [user@host /home/alex]$ snmpget cisco public 2.2.1.10.4 2.2.1.16.4

          interfaces.ifTable.ifEntry.ifInOctets.4 = 2290729126
          interfaces.ifTable.ifEntry.ifOutOctets.4 = 1256486519

       Entonces, tengo 2 OIDs que monitorizar, y son (en el for-
       mato largo, ahora):

          1.3.6.1.2.1.2.2.1.10

               y

          1.3.6.1.2.1.2.2.1.16

       , ambas con el n'umero de interfaz de 4

       No te enga~nes, esto no lo logre yo al primer intento. Me
       tom'o un tiempo entender lo que significaban todos estos
       n'umeros; ayuda cuando se traducen en un texto descrip-
       tivo... por lo menos, cuando oigas hablar de MIBs y OIDs,
       ahora sabr'as de qu'e se trata. No te olvides del n'umero de
       interfaz (0 si el valor no depende de una interfaz), y
       prueba con snmpwalk si no obtienes una respuesta clara con
       snmpget.

       Si entendiste todo esto, y obtienes resultados del dispos-
       itivo con el que est'as probando, sigue adelante con el
       tutorial. Si no, vuelve a leer esta secci'on; es importante

       UUnn eejjeemmpplloo rreeaall

       Ok, empecemos con la diversi'on. Primero, crea una base de
       datos nueva. Vamos a guardar en ella 2 contadores, "input"
       y "ouput". Los datos los vamos a guardar en archivos que
       los promediar'an, tomando grupos de 1, 6, 24 o 288 mues-
       tras. Tambi'en archivaremos los valores m'aximos. Lo expli-
       caremos con m'as detalle despu'es. El intervalo de tiempo
       entre las muestras ser'a de 300 segundos (5 minutos).

        1 muestra "promediada" sigue siendo 1 muestra cada 5 minutos
        6 muestras promediadas son un promedio de cada 30 minutos
        24 muestras promediadas son un promedio de cada 2 horas
        288 muestras promediadas son un promedio de cada d'ia

       Vamos a tratar de ser compatibles con MRTG, que guarda m'as
       o menos esta cantidad de datos:



        600 muestras de 5 minutos:          2 d'ias y 2 horas
        600 promedios de 30 minutos:        12.5 d'ias
        600 promedios de 2 horas:           50 d'ias
        600 promedios de 1 d'ia:             732 d'ias

       Uniendo todos estos rangos tenemos que en total guardamos
       datos de unos 797 d'ias. RRDtool guarda los datos de una
       forma distinta a MRTG; no empieza el archivo "semanal"
       donde acaba el "diario", sino que ambos archivos contienen
       la informaci'on m'as reciente, ,ipor lo que con RRDtool
       archivamos m'as datos que con MRTG!

       Necesitaremos:

        600 muestras de 5 minutos    (2 d'ias y 2 horas)
        700 entradas de 30 minutos   (2 d'ias y 2 horas, m'as 12.5 d'ias)
        775 entradas de 2 horas      (lo anterior + 50 d'ias)
        797 entradas de 1 d'ia        (lo anterior + 732 d'ias, redondeando)

          rrdtool create myrouter.rrd         \
                   DS:input:COUNTER:600:U:U   \
                   DS:output:COUNTER:600:U:U  \
                   RRA:AVERAGE:0.5:1:600      \
                   RRA:AVERAGE:0.5:6:700      \
                   RRA:AVERAGE:0.5:24:775     \
                   RRA:AVERAGE:0.5:288:797    \
                   RRA:MAX:0.5:1:600          \
                   RRA:MAX:0.5:6:700          \
                   RRA:MAX:0.5:24:775         \
                   RRA:MAX:0.5:288:797

       Lo siguiente es recoger los datos y guardarlos, como en el
       ejemplo siguiente. Esta parcialmente en pseudo-c'odigo, por
       lo que tendr'as que buscar exactamente como hacerlo fun-
       cionar en tu sistema operativo.

          mientras no sea el fin del universo
          hacer
             tomar el resultado de
                 snmpget router community 2.2.1.10.4
             en la variable $in
             tomar el resultado de
                 snmpget router community 2.2.1.16.4
             en la variable $out
             rrdtool update myrouter.rrd N:$in:$out
             esperar 5 minutos
          hecho

       Luego, tras recoger datos por un d'ia, crea una imagen,
       usando:

          rrdtool graph myrouter-day.gif --start -86400 \
                   DEF:inoctets=myrouter.rrd:input:AVERAGE \
                   DEF:outoctets=myrouter.rrd:output:AVERAGE \
                   AREA:inoctets#00FF00:"In traffic" \
                   LINE1:outoctets#0000FF:"Out traffic"

       Este comando debe producir un gr'afico del tr'afico del d'ia.
       Un d'ia son 24 horas, de 60 minutos, de 60 segundos:
       24*60*60=86400, o sea que empezamos a "ahora" menos 86400
       segundos. Definimos (con los DEFs) "inoctets" y "out-
       octets" como los valores promedio de la base da datos
       myrouter.rrd, dibujando un 'area para el tr'afico de entrada
       y una l'inea para el tr'afico de salida.

       Mira la imagen y sigue recogiendo datos por unos cuantos
       d'ias. Si lo deseas, puedes probar con los ejemplos de la
       base de datos de pruebas y ver si puedes hacer trabajar
       las diversas opciones y operaciones.

       Sugerencia:

       Haz un gr'afico que muestre el tr'afico en bytes por segundo
       y en bits por segundo. Colorea el tr'afico Ethernet rojo si
       sobrepasa los cuatro megabits por segundo.

       FFuunncciioonneess ddee ccoonnssoolliiddaaccii''oonn

       Unos cuantos p'arrafos atr'as habl'abamos sobre la posibili-
       dad de guardar el valor m'aximo en vez del promedio. Pro-
       fundicemos un poco en este tema.

       Recordemos lo que habl'abamos sobre la velocidad de un
       coche.  Supongamos que manejamos a 144 KM/H durante 5 min-
       utos y luego nos detiene la polic'ia durante unos 25 minu-
       tos. Al finalizar el rega~no, tomamos nuestro port'atil y
       creamos una imagen desde nuestra base de datos. Si visual-
       izamos la segunda RRA que creamos, tendremos el promedio
       de 6 muestreos. Las velocidades registradas serian
       144+0+0+0+0+0=144, lo que en promedio nos da una velocidad
       de 24 KM/H., con lo que nos igual nos pondr'ian una multa,
       s'olo que no por exceso de velocidad.

       Obviamente, en este caso, no deber'iamos tomar en cuenta
       los promedios. Estos son 'utiles en varios casos. Por ejem-
       plo, si queremos ver cuantos KM hemos viajado, este ser'ia
       el gr'afico m'as indicado. Pero por otro lado, para ver la
       velocidad ha la que hemos viajado, los valores m'aximos son
       m'as adecuados.

       Es lo mismo con los datos que recogemos. Si quieres saber
       la cantidad total, mira los promedios. Si quieres ver la
       velocidad, mira los m'aximos. Con el tiempo, ambas canti-
       dades se separan cada vez m'as.  En la 'ultima base de datos
       que creamos, hab'ia dos archivos que guardaban los datos de
       cada d'ia. El archivo que guarda los promedios mostrar'a
       valores bajos, mientras que el de m'aximos mostrar'a valores
       m'as altos. Para mi coche, mostrar'ia valores promedio de
       96/24=4 KM/H (viajo unos 96 kil'ometros por d'ia), y m'aximos
       de 1220 KM/H (la velocidad m'axima que alcanzo cada d'ia)

       Como ves, una gran diferencia. No mires el segundo gr'afico
       para estimar la distancia que recorro, ni al primero para
       estimar la velocidad a la que voy. Esto s'olo funciona con
       muestras muy cercanas, pero no si sacas promedios.

       Algunas veces, hago un viaje largo. Si hago un recorrido
       por Europa, conduciendo por unas 12 horas, el primer
       gr'afico subir'a a unos 60 KM/H. El segundo mostrar'a unos
       180 KM/H. Esto significa que recorr'i unos 60 KM/H por 24
       horas = 1440 KM. Muestra adem'as que fui a una velocidad
       promedio mayor a la normal y a un m'aximo de 180 KM/H, ,ino
       que fui 8 horas a una velocidad fija de 180 KM/H! Este es
       un ejemplo real: tengo que seguir la corriente en las
       autopistas de Alemania, detenerme por gasolina y caf'e de
       vez en cuando, manejar m'as lentamente por Austria y
       Holanda, e ir con cuidado en las monta~nas y las villas. Si
       vi'eramos los gr'aficos de los promedios de cada 5 minutos,
       la imagen ser'ia completamente distinta; ver'iamos los mis-
       mos valores de promedio y de m'axima. (suponiendo que las
       mediciones fueran cada 300 segundos). Se podr'ia ver cuando
       par'e, cuando iba en primera, cuando iba por las
       autopistas, etc. La granularidad de los datos es m'as alta,
       por lo que se tiene m'as informaci'on. Sin embargo, esto nos
       lleva unas 12 muestras por hora, o 288 al d'ia, lo cual es
       mucho para guardar por un periodo de tiempo largo. Por lo
       tanto, sacamos el promedio, guardando eventualmente un
       solo valor por d'ia.  Con este 'unico valor, no podemos ver
       mucho.

       Es importante comprender lo que expuesto en estos 'ultimos
       p'arrafos.  Unos ejes y unas l'ineas no tienen ning'un valor
       por si mismos; hay que saber que representan e interpretar
       correctamente los valores obtenidos. Sean cuales sean los
       datos, esto siempre ser'a cierto.

       El mayor error que puedes cometer es usar los datos
       recogidos para algo para lo cual no sirven. En ese caso,
       seria hasta mejor no tener gr'afico alguno.

       RReeppaasseemmooss lloo qquuee ssaabbeemmooss

       Ahora ya sabes como crear una base de datos. Puedes
       guardar valores en ella, extraerlos creando un gr'afico,
       hacer operaciones matem'aticas con ellos desde la base de
       datos y visualizar los resultados de estas en vez de los
       datos originales. Vimos la diferencia entre los promedios
       y los m'aximos y cuando debemos usar cada uno (o al menos
       una idea de ello)

       RRDtool puede hacer m'as de lo que hemos visto hasta ahora.
       Pero antes de continuar, te recomiendo que releas el texto
       desde el principio y pruebes a hacerle algunas modifica-
       ciones a los ejemplos.  Aseg'urate de entenderlo todo. El
       esfuerzo valdr'a la pena, y te ayudar'a, no s'olo con el
       resto del documento, sino en tu trabajo diario de monitor-
       izaci'on, mucho despu'es de terminar con esta introducci'on.

       TTiippooss ddee ffuueenntteess ddee ddaattooss

       De acuerdo, quieres continuar. Bienvenido de vuelta otra
       vez y prep'arate; voy a ir m'as r'apido con los ejemplos y
       explicaciones.

       Ya vimos que, para ver el cambio de un contador a lo largo
       del tiempo, tenemos que tomar dos n'umeros y dividir la
       diferencia entre el tiempo transcurrido entre las medi-
       ciones. Para los ejemplos que hemos visto es lo l'ogico,
       pero hay otras posibilidades. Por ejemplo, mi enrutador me
       puede dar la temperatura actual en tres puntos distintos,
       la entrada de aire, el llamado "punto caliente" y la sal-
       ida de ventilaci'on. Estos valores no son contadores; si
       tomo los valores de dos muestreos y lo divido entre 300
       segundos, obtendr'e el cambio de temperatura por segundo.
       ,iEsperemos que sea cero, o tendr'iamos un incendio en el
       cuarto de ordenadores! :)

       Entonces, 'cque hacemos? Podemos decirle a RRDtool que
       guarde los valores tal como los medimos (esto no es exac-
       tamente as'i, pero se aproxima bastante a la verdad). As'i,
       los gr'aficos se ver'an mucho mejor. Puedo ver cuando el
       enrutador est'a trabajando m'as (en serio, funciona; como
       usa m'as electricidad, genera m'as calor y sube la temper-
       atura), puedo saber cuando me he dejado las puertas abier-
       tas (el cuarto de ordenadores tiene aire acondicionado;
       con las puertas abiertas el aire caliente del resto del
       edificion entra y sube la temperatura en la entrada de
       aire del enrutador), etc. Antes usamos un tipo de datos de
       "contador", ahora usaremos un tipo de datos diferente, con
       un nombre diferente, GAUGE.  Tenemos otros tipos:

        - COUNTER este ya lo conocemos
        - GAUGE   este acabamos de verlo
        - DERIVE
        - ABSOLUTE

       Los otros dos tipos son DERIVE y ABSOLUTE. ABSOLUTE puede
       usarse igual que COUNTER, con una diferencia; RRDtool
       asume que el contador se reinicia cada vez que se lee. O
       en otras palabras; el delta entre los valores no hay que
       calcularlo, mientras que con COUNTER RRDtool tiene que
       sacar 'el la cuenta. Por ejemplo, nuestro primer ejemplo,
       (12345, 12357, 12363, 12363), ser'ia (unknown, 12, 6, 0) en
       ABSOLUTE.  El otro tipo, DERIVE, es como COUNTER, pero al
       contrario de COUNTER, este valor tambi'en puede decrecer,
       por lo que puede tenerse un delta negativo.

       Vamos a probarlos todos:

          rrdtool create all.rrd --start 978300900 \
                   DS:a:COUNTER:600:U:U \
                   DS:b:GAUGE:600:U:U \
                   DS:c:DERIVE:600:U:U \
                   DS:d:ABSOLUTE:600:U:U \
                   RRA:AVERAGE:0.5:1:10
          rrdtool update all.rrd \
                   978301200:300:1:600:300    \
                   978301500:600:3:1200:600   \
                   978301800:900:5:1800:900   \
                   978302100:1200:3:2400:1200 \
                   978302400:1500:1:2400:1500 \
                   978302700:1800:2:1800:1800 \
                   978303000:2100:4:0:2100    \
                   978303300:2400:6:600:2400  \
                   978303600:2700:4:600:2700  \
                   978303900:3000:2:1200:3000
          rrdtool graph all1.gif -s 978300600 -e 978304200 -h 400 \
                   DEF:linea=all.rrd:a:AVERAGE LINE3:linea#FF0000:"Line A" \
                   DEF:lineb=all.rrd:b:AVERAGE LINE3:lineb#00FF00:"Line B" \
                   DEF:linec=all.rrd:c:AVERAGE LINE3:linec#0000FF:"Line C" \
                   DEF:lined=all.rrd:d:AVERAGE LINE3:lined#000000:"Line D"

       RRRRDDttooooll bbaajjoo eell mmiiccrroossccooppiioo


       +o   La l'inea A es un contador, por lo que debe incremen-
           tarse continuamente y RRDtool tiene que calcular las
           diferencias. Adem'as RRDtool tiene que dividir la
           diferencia entre el tiempo transcurrido. Esto deber'ia
           terminar con una l'inea recta en 1 (los deltas son 300,
           y los intervalos son de 300)

       +o   La l'inea B es de tipo GAUGE. Estos son los valores
           "reales", as'i que el gr'afico debe mostrar lo mismo que
           los valores que introducimos: una especie de onda

       +o   La l'inea C es de tipo DERIVE. Es un contador, y puede
           decrecer. Va entre 2400 y 0, con 1800 en el medio.

       +o   La l'inea D es de tipo ABSOLUTE. Esto es, es un conta-
           dor pero no hay que calcular las diferencias. Los
           n'umeros son iguales a la l'inea A, y espero que puedas
           ver la diferencia en los gr'aficos.

       Esto equivale a los valores siguientes, empezando a las
       23:10 y terminando a las 00:10 (las U significan descono-
       cido).

        - L'inea  A:  u  u  1  1  1  1  1  1  1  1  1  u
        - L'inea  B:  u  1  3  5  3  1  2  4  6  4  2  u
        - L'inea  C:  u  u  2  2  2  0 -2 -6  2  0  2  u
        - L'inea  D:  u  1  2  3  4  5  6  7  8  9 10  u

       Si tu archivo GIF muestra todo esto, has entrado los datos
       correctamente, tu programa RRDtool est'a funcionando bien,
       el visor de gr'aficos no te enga~na y hemos entrado en el
       2000 sin problemas :) Puedes probar el mismo ejemplo cua-
       tro veces, una por cada l'inea.

       Revisemos los datos otra vez:

       +o   L'inea A: 300, 600, 900 , etc.  La diferencia del con-
           tador es siempre 300, igual que el intervalo de tiempo
           transcurrido entre mediciones. Por lo tanto, el prome-
           dio siempre es 1. Pero, 'cpor qu'e el primer punto tiene
           un valor de "desconocido"? 'cAcaso no era conocido el
           valor que pusimos en la base de datos? ,iSi! Pero no
           ten'iamos un valor inicial para calcular la diferencia.
           Ser'ia un error asumir que el contador empezaba en 0,
           as'i que no conocemos el valor de la diferencia

       +o   L'inea B: No hay nada que calcular, los valores son los
           mismos que se introdujeron en la base de datos.

       +o   L'inea C: De nuevo, no conocemos el valor inicial antes
           de la primera medici'on, as'i que se aplica el mismo
           razonamiento que para la l'inea A. En este caso las
           diferencias no son constantes, as'i que la l'inea no es
           recta. Si hubi'esemos puesto los mismos valores que en
           la l'inea A, el gr'afico ser'ia el mismo. Al contrario
           que COUNTER, el valor puede decrecer, y espero
           mostrarte m'as adelante el por que de la diferencia
           entre ambos tipos.

       +o   L'inea D: En este caso, el dispositivo nos da las
           diferencias por s'i mismo. Por lo tanto, conocemos la
           diferencia inicial, y podemos graficarla. Tenemos los
           mismos valores que en la l'inea A, pero su significado
           es distinto, por lo que el gr'afico tambi'en lo es. En
           este caso, las diferencias se incrementan en 300 cada
           vez, mientras que el intervalo de tiempo permanece
           constante en 300 segundos, por lo que la divisi'on nos
           da resultados cada vez mayores.

       RReeiinniicciiaalliizzaaccii''oonn ddee llooss ccoonnttaaddoorreess

       Todav'ia nos quedan algunas cosas por ver. Nos quedan algu-
       nas opciones importantes por cubrir, y aun no hemos
       hablado de la reinicializaci'on de contadores. Empecemos
       por ah'i: Estamos en nuestro coche, vemos el contador y
       muestra 999987. Andamos unos 20 KM, as'i que el contador
       debe subir a 1000007. Desafortunadamente, el contador s'olo
       tiene 6 d'igitos, as'i que en realidad nos muestra 000007.
       Si estuvi'eramos guardando los valores en un tipo DERIVE,
       esto significar'ia que el contador retrocedi'o unos 999980
       KM. Por supuesto esto no es cierto, por lo que necesitamos
       alguna protecci'on contra estos casos. Esta protecci'on s'olo
       la tenemos para el tipo COUNTER, el cual de todas formas
       era el que ten'iamos que haber usado para este tipo de con-
       tador. 'cC'omo funciona? Los valores tipo COUNTER no deben
       decrecer nunca, ,ipor lo que RRDtool asume en ese caso que
       el contador se ha reinicializado! Si la diferencia es neg-
       ativa, esto se compensa sumando el valor m'aximo del conta-
       dor + 1. Para nuestro coche, tendr'iamos:

        Delta = 7 - 999987 = -999980    (en vez de 1000007-999987=20)

        Delta real= -999980 + 999999 + 1 = 20

       Al momento de escribir este documento, RRDtool maneja con-
       tadores de 32 o 64 bits de tama~no. Estos contadores pueden
       manejar los siguientes valores:

        - 32 bits: 0 ..           4294967295
        - 64 bits: 0 .. 18446744073709551615

       Si estos valores te parecen raros, podemos verlos en for-
       mato hexadecimal:

        - 32 bits: 0 ..         FFFFFFFF
        - 64 bits: 0 .. FFFFFFFFFFFFFFFF

       RRDtool maneja ambos contadores de la misma manera. Si
       ocurre un desbordamiento y la diferencia es negativa, RRD-
       tool le suma primero el m'aximo del contador "menor" (32
       bits) + 1 a la diferencia. Si a'un as'i la diferencia es
       negativa, entonces el contador reinicializado era mayor
       (64 bits), por lo que se le suma el valor m'aximo del con-
       tador "largo" + 1 y se le resta el m'aximo del contador
       "peque~no" que sumamos err'oneamente. Hay un problema con
       esto: supongamos que un contador largo se ha reinicial-
       izado al sum'arsele una diferencia muy grande; entonces es
       posible que al a~nadir el valor m'aximo del contador peque~no
       la diferencia nos d'e positivo. En este caso poco probable,
       los valores resultantes no serian correctos. Para que
       ocurra esto, el incremento tiene que ser casi tan grande
       como el valor m'aximo del contador, por lo que de ocurrir
       es muy probable que halla varios problemas m'as en la con-
       figuraci'on y no merezca la pena preocuparse s'olo por este.
       A'un as'i, he incluido un ejemplo de este caso para que lo
       puedas juzgar por ti mismo.

       A continuaci'on, unos ejemplos de reinicializaci'on de los
       contadores. Prueba de hacer los c'alculos por ti mismo, o
       acepta mis resultados si tu calculadora no puede con los
       n'umeros :)

       N'umeros de correcci'on:

        - 32 bits: (4294967295+1) =                                 4294967296
        - 64 bits: (18446744073709551615+1)-correction1 = 18446744069414584320

        Antes:          4294967200
        Incremento:            100
        Deber'ia ser:    4294967300
        Pero es:                 4
        Diferencia:    -4294967196
        Correcci'on #1: -4294967196 + 4294967296 = 100

        Antes:          18446744073709551000
        Incremento:                      800
        Deber'ia ser:    18446744073709551800
        Pero es:                         184
        Diferencia:    -18446744073709550816
        Correcci'on #1: -18446744073709550816 +4294967296 = -18446744069414583520
        Correcci'on #2: -18446744069414583520 +18446744069414584320 = 800

        Antes:          18446744073709551615 ( valor m'aximo )
        Incremento:     18446744069414584320 ( incremento absurdo,
        Deber'ia ser:    36893488143124135935   m'inimo para que
        Pero es:        18446744069414584319   funcione el ejemplo)
        Diferencia:              -4294967296
        Correcci'on #1:  -4294967296 + 4294967296 = 0 (positivo,
                                                      por tanto no se hace
                                                      la segunda correcci'on)

        Antes:          18446744073709551615 ( valor m'aximo )
        Incremento:     18446744069414584319
        Deber'ia ser:    36893488143124135934
        Pero es:        18446744069414584318
        Diferencia:              -4294967297
        Correcci'on #1:  -4294967297 +4294967296 = -1
        Correcci'on #2:  -1 +18446744069414584320 = 18446744069414584319

       Como puede verse en los 'ultimos ejemplos, necesitas unos
       valores bastante extra~nos para hacer que RRDtool falle
       (asumiendo que no tenga ning'un error el programa, por
       supuesto), as'i que esto no deber'ia ocurrir. Sin embargo,
       SNMP o cualquier otro m'etodo que uses de recogida de datos
       puede tambi'en reportar alg'un valor err'oneo ocasionalmente.
       No podemos prevenir todos los errores, pero podemos tomar
       algunas medidas. El comando "create" de RRDtool tiene dos
       par'ametros especialmente para esto, que definen los val-
       ores m'inimo y m'aximo permitidos. Hasta ahora hemos usado
       "U", "desconocido". Si le pasas valores para uno o ambos
       par'ametros y RRDtool recibe un valor fuera de esos
       l'imites, los ignorar'a. Para un term'ometro en grados Cel-
       sius, el m'inimo absoluto es -273. Para mi enrutador, puedo
       asumir que ese m'inimo es mucho mayor, digamos que 10.  La
       temperatura m'axima la pondr'ia en unos 80 grados; m'as alto
       y el aparato no funcionar'ia. Para mi coche, nunca
       esperar'ia obtener valores negativos, y tampoco esperar'ia
       valores mayores a 230.  Cualquier otra cosa ser'ia un
       error. Pero recuerda, lo contrario no es cierto: si los
       valores pasan este examen no quiere decir que sean los
       correctos. Siempre examina bien el gr'afico si los valores
       parecen extra~nos.

       RReemmuueessttrreeoo ddee llooss ddaattooss

       Hay una funcionalidad importante de RRDtool que no hemos
       explicado todav'ia: es virtualmente imposible recoger los
       datos y pasarselos a RRDtool a intervalos exactos de
       tiempo. Por tanto, RRDtool interpola los datos a los
       intervalos exactos. Si no sabes que significa esto o como
       se hace, he aqu'i la ayuda que necesitas:

       Supongamos un contador se incremente exactamente en 1 cada
       segundo.  Queremos medirlo cada 300 segundos, por lo que
       deber'iamos tener valores separados exactamente en 300. Sin
       embargo, por varias circunstancias llegamos unos segundos
       tarde y el intervalo es 303. La diferencia ser'a por tanto
       303. Obviamente, RRDtool no debe colocar 303 en la base de
       datos y dar as'i la impresi'on de que el contador se incre-
       ment'o 303 en 300 segundos. Aqu'i es donde RRDtool inter-
       pola: alter'a el valor 303 al valor que tendr'ia 3 segundos
       antes y guarda 300 en 300 segundos. Digamos que la pr'oxima
       vez llegamos justo a tiempo; por tanto, el intervalo
       actual es 297 segundos, por lo que el contador deber'ia ser
       297. De nuevo, RRDtool altera el valor y guarda 300, como
       debe ser.

                en RRD                     en realidad
        tiempo+000:   0 delta="U"    tiempo+000:   0 delta="U"
        tiempo+300: 300 delta=300    tiempo+300: 300 delta=300
        tiempo+600: 600 delta=300    tiempo+603: 603 delta=303
        tiempo+900: 900 delta=300    tiempo+900: 900 delta=297

       Creemos dos bases de datos id'enticas. He escogido el rango
       de tiempo entre 920805000 y 920805900.

          rrdtool create seconds1.rrd   \
             --start 920804700          \
             DS:seconds:COUNTER:600:U:U \
             RRA:AVERAGE:0.5:1:24

          para Unix: cp seconds1.rrd seconds2.rrd
          para DOS: copy seconds1.rrd seconds2.rrd
          para VMS:  y yo que s'e :)

          rrdtool update seconds1.rrd \
             920805000:000 920805300:300 920805600:600 920805900:900
          rrdtool update seconds2.rrd \
             920805000:000 920805300:300 920805603:603 920805900:900

          rrdtool graph seconds1.gif                       \
             --start 920804700 --end 920806200             \
             --height 200                                  \
             --upper-limit 1.05 --lower-limit 0.95 --rigid \
             DEF:seconds=seconds1.rrd:seconds:AVERAGE      \
             CDEF:unknown=seconds,UN                       \
             LINE2:seconds#0000FF                          \
             AREA:unknown#FF0000
          rrdtool graph seconds2.gif                       \
             --start 920804700 --end 920806200             \
             --height 200                                  \
             --upper-limit 1.05 --lower-limit 0.95 --rigid \
             DEF:seconds=seconds2.rrd:seconds:AVERAGE      \
             CDEF:unknown=seconds,UN                       \
             LINE2:seconds#0000FF                          \
             AREA:unknown#FF0000

       Los dos gr'aficos debe ser iguales.

RREESSUUMMEENN
       Es hora de concluir este documento. Ahora debes conocer lo
       b'asico como para trabajar con RRDtool y leer la docu-
       mentaci'on. A'un hay mucho m'as por descubrir acerca de RRD-
       tool, y le encontrar'as; m'as y m'as usos para la her-
       ramienta. Con los ejemplos y la herramienta puedes crear
       f'acilmente muchos gr'aficos; tambi'en puedes usar las inter-
       faces disponibles.

LLIISSTTAA DDEE CCOORRRREEOO
       Recuerda subscribirte a la lista de correo. Aunque no con-
       testes los correos que aparecen en ella, te servir'a de
       ayuda a ti y a los dem'as.  Mucho de lo que se sobre MRTG
       (y por tanto sobre RRDtool), lo aprend'i tan s'olo con leer
       la lista, sin escribir. No hay por que preguntar las pre-
       guntas b'asicas, que ya tienen su respuesta en la FAQ
       (,il'eela!). Con miles de usuarios a lo largo del mundo,
       siempre hay preguntas que tu puedes responder con lo
       aprendido en este y otros documentos.

VVEERR TTAAMMBBII''EENN
       Las p'aginas del manual de RRDtool

AAUUTTOORR
       Espero que hayas disfrutado con los ejemplos y las
       descripciones.  Si es as'i, ayuda a otros refiri'endolos a
       este documento cuando te hagan preguntas b'asicas. No s'olo
       obtendr'an la respuesta, sino que aprender'an muchas otras
       cosas.

       Alex van den Bogaerdt <alex@ergens.op.het.net>



1.0.50                      2004-01-17          RRDTUTORIAL.ES(1)
