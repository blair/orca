


rrdtool                                            BIN_DEC_HEX(1)



NNNNAAAAMMMMEEEE
     Binary Decimal Hexadecimal - How does it work

DDDDEEEESSSSCCCCRRRRIIIIPPPPTTTTIIIIOOOONNNN
     Most people use the decimal numbering system. This system
     uses ten symbols to represent numbers. When those ten
     symbols are used up, they start all over again and increment
     the position just before this. The digit 0 is only shown if
     it is the only symbol in the sequence, or if it is not the
     first one.

     If this sounds as crypto to you, this is what I've said in
     numbers:

          0
          1
          2
          3
          4
          5
          6
          7
          8
          9
         10
         11
         12
         13

     and so on.

     Each time the digit nine should be incremented, it is reset
     to 0 and the position before is incremented. Then number 9
     can be seen as "00009" and when we should increment 9, we
     reset it to zero and increment the digit just before the 9
     so the number becomes "00010". For zero's we write a space
     if it is not the only digit (so: number 0) and if it is the
     first digit: "00010" -> " 0010" -> "  010" -> "   10". It is
     not "   1 ".

     This was pretty basic, you already knew this. Why did I tell
     it ?  Well, computers do not represent numbers with 10
     different digits. They know of only two different symbols,
     being 0 and 1. Apply the same rules to this set of digits
     and you get the binary numbering system:










2001-02-20             Last change: 1.0.33                      1






rrdtool                                            BIN_DEC_HEX(1)



          0
          1
         10
         11
        100
        101
        110
        111
       1000
       1001
       1010
       1011
       1100
       1101

     and so on.

     If you count the number of rows, you'll see that these are
     again 14 different numbers. The numbers are the same and
     mean the same. It is only a different representation. This
     means that you have to know the representation used, or as
     it is called the numbering system or base.  Normally if we
     do not speak about the numbering system used, we're using
     the decimal system. If we are talking about another
     numbering system, we'll have to make that clear. There are a
     few wide-spread methods to do so. One common form is to
     write _1_0_1_0(2) which means that you wrote down a number in
     the binary form. It is the number ten.  If you would write
     1010 it means the number one thousand and ten.

     In books, another form is most used. It uses subscript
     (little chars, more or less in between two rows). You can
     leave out the parentheses in that case and write down the
     number in normal characters followed with a little two just
     behind it.

     The numbering system used is also called the base. We talk
     of the number 1100 base 2, the number 12 base 10.

     For the binary system, is is common to write leading zero's.
     The numbers are written down in series of four, eight or
     sixteen depending on the context.

     We can use the binary form when talking to computers
     (...programming...)  but the numbers will have large
     representations. The number 65535 would be written down as
     _1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1(2) which is 16 times the digit 1.  This is
     difficult and prone to errors. Therefore we normally would
     use another base, called hexadecimal. It uses 16 different
     symbols. First the symbols from the decimal system are used,
     thereafter we continue with the alphabetic characters. We
     get 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E and F. This



2001-02-20             Last change: 1.0.33                      2






rrdtool                                            BIN_DEC_HEX(1)



     system is chosen because the hexadecimal form can be
     converted into the binary system very easy (and back).

     There is yet another system in use, called the octal system.
     This was more common in the old days but not anymore. You
     will find it in use on some places so get used to it. The
     same story applies, but now with only eight different
     symbols.

      Binary      (2)
      Octal       (8)
      Decimal     (10)
      Hexadecimal (16)

      (2)    (8) (10) (16)
      00000   0    0    0
      00001   1    1    1
      00010   2    2    2
      00011   3    3    3
      00100   4    4    4
      00101   5    5    5
      00110   6    6    6
      00111   7    7    7
      01000  10    8    8
      01001  11    9    9
      01010  12   10    A
      01011  13   11    B
      01100  14   12    C
      01101  15   13    D
      01110  16   14    E
      01111  17   15    F
      10000  20   16   10
      10001  21   17   11
      10010  22   18   12
      10011  23   19   13
      10100  24   20   14
      10101  25   21   15

     Most computers used nowadays are using bytes of eight bits.
     This means that they store eight bits at a time. You can see
     why the octal system is not the most preferred for that:
     You'd need three digits to represent the eight bits and this
     means that you'd have to use one complete digit to represent
     only two bits (2+3+3=8). This is a waste. For hexadecimal
     digits, you need only two digits which are used completely:

      (2)      (8)  (10) (16)
      11111111 377  255   FF

     You can see why binary and hexadecimal can be converted
     quickly: For each hexadecimal digit there are exactly four
     binary digits.  Take a binary number. Each time take four



2001-02-20             Last change: 1.0.33                      3






rrdtool                                            BIN_DEC_HEX(1)



     digits from the right and make a hexadecimal digit from it
     (see the table above). Stop when there are no more digits.
     Other way around: Take a hexadecimal number. For each digit,
     write down its binary equivalent.

     Computers (or rather the parsers running on them) would have
     a hard time converting a number like 1234(16). Therefore
     hexadecimal numbers get a prefix. This prefix depends on the
     language you're writing in. Some of the prefixes are "0x"
     for C, "$" for Pascal, "#" for HTML.  It is common to assume
     that if a number starts with a zero, it is octal.  It does
     not matter what is used as long as you know what it is.  I
     will use "0x" for hexadecimal, "%" for binary and "0" for
     octal.  The following numbers are all the same, just the way
     they are written is different:  021  0x11  17  %00010001

     To do arithmetics and conversions you need to understand one
     more thing.  It is something you already know but perhaps
     you do not "see" it yet:

     If you write down 1234, (so it is decimal) you are talking
     about the number one thousand, two hundred and thirty four.
     In sort of a formula:

      1 * 1000 = 1000
      2 *  100 =  200
      3 *   10 =   30
      4 *    1 =    4

     This can also be written as:

      1 * 10^3
      2 * 10^2
      3 * 10^1
      4 * 10^0

     where ^ means "to the power of".

     We are using the base 10, and the positions 0,1,2 and 3.
     The right-most position should NOT be multiplied with 10.
     The second from the right should be multiplied one time with
     10. The third from the right is multiplied with 10 two
     times. This continues for whatever positions are used.

     It is the same in all other representations:

     0x1234 will be

      1 * 16^3
      2 * 16^2
      3 * 16^1
      4 * 16^0



2001-02-20             Last change: 1.0.33                      4






rrdtool                                            BIN_DEC_HEX(1)



     01234 would be

      1 * 8^3
      2 * 8^2
      3 * 8^1
      4 * 8^0

     This example can not be done for binary as that system can
     only use two symbols. Another example:

     %1010 would be

      1 * 2^3
      0 * 2^2
      1 * 2^1
      0 * 2^0

     It would have been more easy to convert it to its
     hexadecimal form and just translate %1010 into 0xA. After a
     while you get used to it. You will not need to do any
     calculations anymore but just know that 0xA means 10.

     To convert a decimal number into a hexadecimal one you could
     use the next method. It will take some time to be able to do
     the estimates but it will be more and more easy when you use
     the system more frequent. Another way is presented to you
     thereafter.

     First you will need to know how many positions will be used
     in the other system. To do so, you need to know the maximum
     numbers. Well, that's not so hard as it looks. In decimal,
     the maximum number that you can form with two digits is
     "99". The maximum for three: "999". The next number would
     need an extra position. Reverse this idea and you will see
     that the number can be found by taking 10^3 (10*10*10 is
     1000) minus 1 or 10^2 minus one.

     This can be done for hexadecimal too:

      16^4 = 0x10000 = 65536
      16^3 =  0x1000 =  4096
      16^2 =   0x100 =   256
      16^1 =    0x10 =    16

     If a number is smaller than 65536 it will thus fit in four
     positions.  If the number is bigger than 4095, you will need
     to use position 4.  How many times can you take 4096 from
     the number without going below zero is the first digit you
     write down. This will always be a number from 1 to 15 (0x1
     to 0xF). Do the same for the other positions.





2001-02-20             Last change: 1.0.33                      5






rrdtool                                            BIN_DEC_HEX(1)



     Number is 41029. It is smaller than 16^4 but bigger than
     16^3-1. This means that we have to use four positions.  We
     can subtract 16^3 from 41029 ten times without going below
     zero.  The leftmost digit will be "A" so we have 0xA????.
     The number is reduced to 41029 - 10*4096 = 41029-40960 = 69.
     69 is smaller than 16^3 but not bigger than 16^2-1. The
     second digit is therefore "0" and we know 0xA0??.  69 is
     smaller than 16^2 and bigger than 16^1-1. We can subtract
     16^1 (which is just plain 16) four times and write down "4"
     to get 0xA04?.  Take 64 from 69 (69 - 4*16) and the last
     digit is 5 --> 0xA045.

     The other method builds the number from the right. Take
     again 41029.  Divide by 16 and do not use fractions (only
     whole numbers).

      41029 / 16 is 2564 with a remainder of 5. Write down 5.
      2564 / 16 is 160 with a remainder of 4. Write the 4 before the 5.
      160 / 16 is 10 with no remainder. Prepend 45 with 0.
      10 / 16 is below one. End here and prepend 0xA. End up with 0xA045.

     Which method to use is up to you. Use whatever works for
     you. Personally I use them both without being able to tell
     what method I use in each case, it just depends on the
     number, I think. Fact is, some numbers will occur frequently
     while programming, if the number is close then I will use
     the first method (like 32770, translate into 32768 + 2 and
     just know that it is 0x8000 + 0x2 = 0x8002).

     For binary the same approach can be used. The base is 2 and
     not 16, and the number of positions will grow rapidly. Using
     the second method has the advantage that you can see very
     simple if you should write down a zero or a one: if you
     divide by two the remainder will be zero if it was an even
     number and one if it was an odd number:

      41029 / 2 = 20514 remainder 1
      20514 / 2 = 10257 remainder 0
      10257 / 2 =  5128 remainder 1
       5128 / 2 =  2564 remainder 0
       2564 / 2 =  1282 remainder 0
       1282 / 2 =   641 remainder 0
        641 / 2 =   320 remainder 1
        320 / 2 =   160 remainder 0
        160 / 2 =    80 remainder 0
         80 / 2 =    40 remainder 0
         40 / 2 =    20 remainder 0
         20 / 2 =    10 remainder 0
         10 / 2 =     5 remainder 0
          5 / 2 =     2 remainder 1
          2 / 2 =     1 remainder 0
          1 / 2 below 0 remainder 1



2001-02-20             Last change: 1.0.33                      6






rrdtool                                            BIN_DEC_HEX(1)



     Write down the results from right to left: %1010000001000101

     Group by four:

      %1010000001000101
      %101000000100 0101
      %10100000 0100 0101
      %1010 0000 0100 0101

     Convert into hexadecimal: 0xA045

     Group %1010000001000101 by three and convert into octal:

      %1010000001000101
      %1010000001000 101
      %1010000001 000 101
      %1010000 001 000 101
      %1010 000 001 000 101
      %1 010 000 001 000 101
      %001 010 000 001 000 101
         1   2   0   1   0   5 --> 0120105

      So: %1010000001000101 = 0120105 = 0xA045 = 41029
      Or: 1010000001000101(2) = 120105(8) = A045(16) = 41029(10)
      Or: 1010000001000101(2) = 120105(8) = A045(16) = 41029

     At first while adding numbers, you'll convert them to their
     decimal form and then back into their original form after
     doing the addition.  If you use the other numbering system
     often, you will see that you'll be able to do arithmetics in
     the base that is used.  In any representation it is the
     same, add the numbers on the right, write down the rightmost
     digit from the result, remember the other digits and use
     them in the next round. Continue with the second digits from
     the right and so on:

         %1010 + %0111 --> 10 + 7 --> 17 --> %00010001

     will become

         %1010
         %0111 +
          ||||
          |||+-- add 0 + 1, result is 1, nothing to remember
          ||+--- add 1 + 1, result is %10, write down 0 and remember 1
          |+---- add 0 + 1 + 1(remembered), result = 0, remember 1
          +----- add 1 + 0 + 1(remembered), result = 0, remember 1
                 nothing to add, 1 remembered, result = 1
      --------
        %10001 is the result, I like to write it as %00010001

     For low values, try to do the calculations yourself, check



2001-02-20             Last change: 1.0.33                      7






rrdtool                                            BIN_DEC_HEX(1)



     them with a calculator. The more you do the calculations
     yourself, the more you find that you didn't make mistakes.
     In the end, you'll do calculi in other bases as easy as you
     do in decimal.

     When the numbers get bigger, you'll have to realize that a
     computer is not called a computer just to have a nice name.
     There are many different calculators available. Use them.
     For Unix you could use "bc" which is called so as it is
     short for Binary Calculator. It calculates not only in
     decimal, but in all bases you'll ever use (among them
     Binary).

     For people on Windows: Start the calculator
     (start->programs->accessories->calculator) and if necessary
     click view->scientific. You now have a scientific calculator
     and can compute in binary or hexadecimal.

AAAAUUUUTTTTHHHHOOOORRRR
     I hope you enjoyed the examples and their descriptions. If
     you do, help other people by pointing them to this document
     when they are asking basic questions. They will not only get
     their answer but at the same time learn a whole lot more.

     Alex van den Bogaerdt <alex@ergens.op.het.net>






























2001-02-20             Last change: 1.0.33                      8



