    <HTML> 
	<HEAD> 
	    <TITLE>Hexadecimal - How does it wok

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->
<!--

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
</UL>
-->
<!-- INDEX END -->

<P>
<H1><A NAME="NAME">NAME

</A></H1>
Binary Decimal Hexadecimal - How does it wok


<P>

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>
Most people use the decimal numbering system. This system uses ten symbols
to represent numbers. When those ten symbols are used up, they start all
over again and increment the position just before this. The digit 0 is only
shown if it is the only symbol in the sequence, or if it is not the first
one.


<P>

If this sounds as crypto to you, this is what I've said in numbers:


<P>

<PRE>     0
     1
     2
     3
     4
     5
     6
     7
     8
     9
    10
    11
    12
    13
</PRE>

<P>

and so on.


<P>

Each time the digit nine should be incremented, it is reset to 0 and the
position before is incremented. Then number 9 can be seen as ``00009'' and
when we should increment 9, we reset it to zero and increment the digit
just before the 9 so the number becomes ``00010''. For zero's we write a
space if it is not the only digit (so: number 0) and if it is the first
digit: ``00010'' -&gt; `` 0010'' -&gt; `` 010'' -&gt; `` 10''. It is not ``
1 ''.


<P>

This was pretty basic, you already knew this. Why did I tell it ? Well,
computers do not represent numbers with 10 different digits. They know of
only two different symbols, being 0 and 1. Apply the same rules to this set
of digits and you get the binary numbering system:


<P>

<PRE>     0
     1
    10
    11
   100
   101
   110
   111
  1000
  1001
  1010
  1011
  1100
  1101
</PRE>

<P>

and so on.


<P>

If you count the number of rows, you'll see that these are again 14
different numbers. The numbers are the same and mean the same. It is only a
different representation. This means that you have to know the
representation used, or as it is called the numbering system or base.
Normally if we do not speak about the numbering system used, we're using
the decimal system. If we are talking about another numbering system, we'll
have to make that clear. There are a few wide-spread methods to do so. One
common form is to write <CODE>1010(2)</CODE> which means that you wrote
down a number in the binary form. It is the number ten. If you would write
1010 it means the number one thousand and ten.


<P>

In books, another form is most used. It uses subscript (little chars, more
or less in between two rows). You can leave out the parentheses in that
case and write down the number in normal characters followed with a little
two just behind it.


<P>

The numbering system used is also called the base. We talk of the number
1100 base 2, the number 12 base 10.


<P>

For the binary system, is is common to write leading zero's. The numbers
are written down in series of four, eight or sixteen depending on the
context.


<P>

We can use the binary form when talking to computers (...programming...)
but the numbers will have large representations. The number 65535 would be
written down as <CODE>1111111111111111(2)</CODE> which is 16 times the
digit 1. This is difficult and prone to errors. Therefore we normally would
use another base, called hexadecimal. It uses 16 different symbols. First
the symbols from the decimal system are used, thereafter we continue with
the alphabetic characters. We get 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D,
E and F. This system is chosen because the hexadecimal form can be
converted into the binary system very easy (and back).


<P>

There is yet another system in use, called the octal system. This was more
common in the old days but not anymore. You will find it in use on some
places so get used to it. The same story applies, but now with only eight
different symbols.


<P>

<PRE> Binary      (2)
 Octal       (8)
 Decimal     (10)
 Hexadecimal (16)
</PRE>

<P>

<PRE> (2)    (8) (10) (16)
 00000   0    0    0
 00001   1    1    1
 00010   2    2    2 
 00011   3    3    3
 00100   4    4    4
 00101   5    5    5
 00110   6    6    6
 00111   7    7    7
 01000  10    8    8
 01001  11    9    9
 01010  12   10    A
 01011  13   11    B
 01100  14   12    C
 01101  15   13    D
 01110  16   14    E
 01111  17   15    F
 10000  20   16   10
 10001  21   17   11
 10010  22   18   12
 10011  23   19   13
 10100  24   20   14
 10101  25   21   15
</PRE>

<P>

Most computers used nowadays are using bytes of eight bits. This means that
they store eight bits at a time. You can see why the octal system is not
the most preferred for that: You'd need three digits to represent the eight
bits and this means that you'd have to use one complete digit to represent
only two bits (2+3+3=8). This is a waste. For hexadecimal digits, you need
only two digits which are used completely:


<P>

<PRE> (2)      (8)  (10) (16)
 11111111 377  255   FF
</PRE>

<P>

You can see why binary and hexadecimal can be converted quickly: For each
hexadecimal digit there are exactly four binary digits. Take a binary
number. Each time take four digits from the right and make a hexadecimal
digit from it (see the table above). Stop when there are no more digits.
Other way around: Take a hexadecimal number. For each digit, write down its
binary equivalent.


<P>

Computers (or rather the parsers running on them) would have a hard time
converting a number like <CODE>1234(16).</CODE> Therefore hexadecimal
numbers get a prefix. This prefix depends on the language you're writing
in. Some of the prefixes are ``0x'' for C, ``$'' for Pascal, ``#'' for
HTML. It is common to assume that if a number starts with a zero, it is
octal. It does not matter what is used as long as you know what it is. I
will use ``0x'' for hexadecimal, ``%'' for binary and ``0'' for octal. The
following numbers are all the same, just the way they are written is
different: 021 0x11 17 <CODE>%00010001</CODE>


<P>

To do arithmetics and conversions you need to understand one more thing. It
is something you already know but perhaps you do not ``see'' it yet:


<P>

If you write down 1234, (so it is decimal) you are talking about the number
one thousand, two hundred and thirty four. In sort of a formula:


<P>

<PRE> 1 * 1000 = 1000
 2 *  100 =  200
 3 *   10 =   30
 4 *    1 =    4
</PRE>

<P>

This can also be written as:


<P>

<PRE> 1 * 10^3
 2 * 10^2
 3 * 10^1
 4 * 10^0
</PRE>

<P>

where ^ means ``to the power of''.


<P>

We are using the base 10, and the positions 0,1,2 and 3. The right-most
position should NOT be multiplied with 10. The second from the right should
be multiplied one time with 10. The third from the right is multiplied with
10 two times. This continues for whatever positions are used.


<P>

It is the same in all other representations:


<P>

0x1234 will be


<P>

<PRE> 1 * 16^3
 2 * 16^2
 3 * 16^1
 4 * 16^0
</PRE>

<P>

01234 would be


<P>

<PRE> 1 * 8^3
 2 * 8^2
 3 * 8^1
 4 * 8^0
</PRE>

<P>

This example can not be done for binary as that system can only use two
symbols. Another example:


<P>

<CODE>%1010</CODE> would be


<P>

<PRE> 1 * 2^3
 0 * 2^2
 1 * 2^1
 0 * 2^0
</PRE>

<P>

It would have been more easy to convert it to its hexadecimal form and just
translate <CODE>%1010</CODE> into 0xA. After a while you get used to it.
You will not need to do any calculations anymore but just know that 0xA
means 10.


<P>

To convert a decimal number into a hexadecimal one you could use the next
method. It will take some time to be able to do the estimates but it will
be more and more easy when you use the system more frequent. Another way is
presented to you thereafter.


<P>

First you will need to know how many positions will be used in the other
system. To do so, you need to know the maximum numbers. Well, that's not so
hard as it looks. In decimal, the maximum number that you can form with two
digits is ``99''. The maximum for three: ``999''. The next number would
need an extra position. Reverse this idea and you will see that the number
can be found by taking 10^3 (10*10*10 is 1000) minus 1 or 10^2 minus one.


<P>

This can be done for hexadecimal too:


<P>

<PRE> 16^4 = 0x10000 = 65536
 16^3 =  0x1000 =  4096
 16^2 =   0x100 =   256
 16^1 =    0x10 =    16
</PRE>

<P>

If a number is smaller than 65536 it will thus fit in four positions. If
the number is bigger than 4095, you will need to use position 4. How many
times can you take 4096 from the number without going below zero is the
first digit you write down. This will always be a number from 1 to 15 (0x1
to 0xF). Do the same for the other positions.


<P>

Number is 41029. It is smaller than 16^4 but bigger than 16^3-1. This means
that we have to use four positions. We can subtract 16^3 from 41029 ten
times without going below zero. The leftmost digit will be ``A'' so we have
0xA????. The number is reduced to 41029 - 10*4096 = 41029-40960 = 69. 69 is
smaller than 16^3 but not bigger than 16^2-1. The second digit is therefore
``0'' and we know 0xA0??. 69 is smaller than 16^2 and bigger than 16^1-1.
We can subtract 16^1 (which is just plain 16) four times and write down
``4'' to get 0xA04?. Take 64 from 69 (69 - 4*16) and the last digit is 5
--&gt; 0xA045.


<P>

The other method builds the number from the right. Take again 41029. Divide
by 16 and do not use fractions (only whole numbers).


<P>

<PRE> 41029 / 16 is 2564 with a remainder of 5. Write down 5.
 2564 / 16 is 160 with a remainder of 4. Write the 4 before the 5.
 160 / 16 is 10 with no remainder. Prepend 45 with 0.
 10 / 16 is below one. End here and prepend 0xA. End up with 0xA045.
</PRE>

<P>

Which method to use is up to you. Use whatever works for you. Personally I
use them both without being able to tell what method I use in each case, it
just depends on the number, I think. Fact is, some numbers will occur
frequently while programming, if the number is close then I will use the
first method (like 32770, translate into 32768 + 2 and just know that it is
0x8000 + 0x2 = 0x8002).


<P>

For binary the same approach can be used. The base is 2 and not 16, and the
number of positions will grow rapidly. Using the second method has the
advantage that you can see very simple if you should write down a zero or a
one: if you divide by two the remainder will be zero if it was an even
number and one if it was an odd number: 41029 / 2 = 20514 remainder 1 20514
/ 2 = 10257 remainder 0 10257 / 2 = 5128 remainder 1 5128 / 2 = 2564
remainder 0 2564 / 2 = 1282 remainder 0 1282 / 2 = 641 remainder 0 641 / 2
= 320 remainder 1 320 / 2 = 160 remainder 0 160 / 2 = 80 remainder 0 80 / 2
= 40 remainder 0 40 / 2 = 20 remainder 0 20 / 2 = 10 remainder 0 10 / 2 = 5
remainder 0 5 / 2 = 2 remainder 1 2 / 2 = 1 remainder 0 1 / 2 below 0
remainder 1


<P>

Write down the results from right to left: <CODE>%1010000001000101</CODE>


<P>

Group by four:


<P>

<PRE> %1010000001000101
 %101000000100 0101
 %10100000 0100 0101
 %1010 0000 0100 0101
</PRE>

<P>

Convert into hexadecimal: 0xA045


<P>

Group <CODE>%1010000001000101</CODE> by three and convert into octal:


<P>

<PRE> %1010000001000101
 %1010000001000 101
 %1010000001 000 101
 %1010000 001 000 101
 %1010 000 001 000 101
 %1 010 000 001 000 101
 %001 010 000 001 000 101
    1   2   0   1   0   5 --&gt; 0120105
</PRE>

<P>

<PRE> So: %1010000001000101 = 0120105 = 0xA045 = 41029
 Or: 1010000001000101(2) = 120105(8) = A045(16) = 41029(10)
 Or: 1010000001000101(2) = 120105(8) = A045(16) = 41029
</PRE>

<P>

At first while adding numbers, you'll convert them to their decimal form
and then back into their original form after doing the addition. If you use
the other numbering system often, you will see that you'll be able to do
arithmetics in the base that is used. In any representation it is the same,
add the numbers on the right, write down the rightmost digit from the
result, remember the other digits and use them in the next round. Continue
with the second digits from the right and so on:


<P>

<PRE>    %1010 + %0111 --&gt; 10 + 7 --&gt; 17 --&gt; %00010001
</PRE>

<P>

will become


<P>

<PRE>    %1010
    %0111 +
     ||||
     |||+-- add 0 + 1, result is 1, nothing to remember
     ||+--- add 1 + 1, result is %10, write down 0 and remember 1
     |+---- add 0 + 1 + 1(remembered), result = 0, remember 1
     +----- add 1 + 0 + 1(remembered), result = 0, remember 1
            nothing to add, 1 remembered, result = 1
 --------
   %10001 is the result, I like to write it as %00010001
</PRE>

<P>

For low values, try to do the calculations yourself, check them with a
calculator. The more you do the calculations yourself, the more you find
that you didn't make mistakes. In the end, you'll do calculi in other bases
as easy as you do in decimal.


<P>

When the numbers get bigger, you'll have to realize that a computer is not
called a computer just to have a nice name. There are many different
calculators available. Use them. For Unix you could use ``bc'' which is
called so as it is short for Binary Calculator. It calculates not only in
decimal, but in all bases you'll ever use (among them Binary).


<P>

For people on Windows: Start the calculator
(start-&gt;programs-&gt;accessories-&gt;calculator) and if necessary click
view-&gt;scientific. You now have a scientific calculator and can compute
in binary or hexadecimal.


<P>

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR

</A></H1>
I hope you enjoyed the examples and their descriptions. If you do, help
other people by pointing them to this document when they are asking basic
questions. They will not only get their answer but at the same time learn a
whole lot more.


<P>

Alex van den Bogaerdt <A
HREF="MAILTO:<alex@ergens.op.het.net>"><alex@ergens.op.het.net></A>

<P>

</DL>
    </BODY>

    </HTML>
