<HTML>
<HEAD>
<TITLE>rrdgraph</TITLE>
<LINK REV="made" HREF="mailto:karrer@zinal.ee.ethz.ch">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->
<!--

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#NOTES_on_legend_arguments">NOTES on legend arguments</A>
	<UL>

		<LI><A HREF="#Escaping_the_colon">Escaping the colon</A>
		<LI><A HREF="#String_Formatting">String Formatting</A>
	</UL>

	<LI><A HREF="#NOTE_on_Return_Values">NOTE on Return Values</A>
	<LI><A HREF="#EXAMPLE_1">EXAMPLE 1</A>
	<LI><A HREF="#EXAMPLE_2">EXAMPLE 2</A>
	<LI><A HREF="#EXAMPLE_3">EXAMPLE 3</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
	<LI><A HREF="#REFERENCES">REFERENCES</A>
</UL>
-->
<!-- INDEX END -->

<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
rrdtool graph - Create a graph based on data from one or several RRD

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<STRONG>rrdtool</STRONG>  <STRONG>graph</STRONG>  <EM>filename</EM> 
 
[<STRONG>-s</STRONG>|<STRONG>--start</STRONG>&nbsp;<EM>seconds</EM>] 
 
[<STRONG>-e</STRONG>|<STRONG>--end</STRONG>&nbsp;<EM>seconds</EM>]

[<STRONG>-x</STRONG>|<STRONG>--x-grid</STRONG>&nbsp;<EM>x-axis&nbsp;grid&nbsp;and&nbsp;label</EM>]

[<STRONG>-y</STRONG>|<STRONG>--y-grid</STRONG>&nbsp;<EM>y-axis&nbsp;grid&nbsp;and&nbsp;label</EM>]

[<STRONG>--alt-y-grid</STRONG>]

[<STRONG>--alt-autoscale</STRONG>]

[<STRONG>-v</STRONG>|<STRONG>--vertical-label</STRONG>&nbsp;<EM>text</EM>]

[<STRONG>-w</STRONG>|<STRONG>--width</STRONG>&nbsp;<EM>pixels</EM>]

[<STRONG>-h</STRONG>|<STRONG>--height</STRONG>&nbsp;<EM>pixels</EM>] 
 
[<STRONG>-i</STRONG>|<STRONG>--interlaced</STRONG>] 
 
[<STRONG>-f</STRONG>|<STRONG>--imginfo</STRONG>&nbsp;<EM>formatstring</EM>] 
 
[<STRONG>-a</STRONG>|<STRONG>--imgformat</STRONG>&nbsp;<STRONG>GIF</STRONG>|<STRONG>PNG</STRONG>] 
 
[<STRONG>-z</STRONG>|<STRONG>--lazy</STRONG>] 
 
[<STRONG>-o</STRONG>|<STRONG>--logarithmic</STRONG>]

[<STRONG>-u</STRONG>|<STRONG>--upper-limit</STRONG>&nbsp;<EM>value</EM>] 
 
[<STRONG>-l</STRONG>|<STRONG>--lower-limit</STRONG>&nbsp;<EM>value</EM>]

[<STRONG>-r</STRONG>|<STRONG>--rigid</STRONG>]

[<STRONG>-b</STRONG>|<STRONG>--base</STRONG>&nbsp;<EM>value</EM>]

[<STRONG>-c</STRONG>|<STRONG>--color</STRONG>&nbsp;<EM>COLORTAG</EM><STRONG>#</STRONG><EM>rrggbb</EM>]



<P>
[<STRONG>-t</STRONG>|<STRONG>--title</STRONG>&nbsp;<EM>title</EM>]

[<STRONG>DEF:</STRONG><EM>vname</EM><STRONG>=</STRONG><EM>rrd</EM><STRONG>:</STRONG><EM>ds-name</EM><STRONG>:</STRONG><EM>CF</EM>]

[<STRONG>CDEF:</STRONG><EM>vname</EM><STRONG>=</STRONG><EM>rpn-expression</EM>]

[<STRONG>PRINT:</STRONG><EM>vname</EM><STRONG>:</STRONG><EM>CF</EM><STRONG>:</STRONG><EM>format</EM>]

[<STRONG>GPRINT:</STRONG><EM>vname</EM><STRONG>:</STRONG><EM>CF</EM><STRONG>:</STRONG><EM>format</EM>]

[<STRONG>COMMENT:</STRONG><EM>text</EM>]

[<STRONG>HRULE:</STRONG><EM>value</EM><STRONG>#</STRONG><EM>rrggbb</EM>[<STRONG>:</STRONG><EM>legend</EM>]]

[<STRONG>VRULE:</STRONG><EM>time</EM><STRONG>#</STRONG><EM>rrggbb</EM>[<STRONG>:</STRONG><EM>legend</EM>]]

[<STRONG>LINE</STRONG>{<STRONG>1</STRONG>|<STRONG>2</STRONG>|<STRONG>3</STRONG>}<STRONG>:</STRONG><EM>vname</EM>[<STRONG>#</STRONG><EM>rrggbb</EM>[<STRONG>:</STRONG><EM>legend</EM>]]]

[<STRONG>AREA:</STRONG><EM>vname</EM>[<STRONG>#</STRONG><EM>rrggbb</EM>[<STRONG>:</STRONG><EM>legend</EM>]]]

[<STRONG>STACK:</STRONG><EM>vname</EM>[<STRONG>#</STRONG><EM>rrggbb</EM>[<STRONG>:</STRONG><EM>legend</EM>]]]



<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
The <STRONG>graph</STRONG> functions main purpose is to create graphical representations of the data
stored in one or several <STRONG>RRD</STRONG>s. Apart from generating graphs, it can also extract numerical reports.

<DL>
<DT><STRONG><A NAME="item_filename">filename</A></STRONG><DD>
<P>
The name of the graph to generate. Since <STRONG>rrdtool</STRONG> outputs GIFs and PNGs, it's recommended that the filename end in either
<EM>.gif</EM> or <EM>.png</EM>.  <STRONG>rrdtool</STRONG> does not enforce this, however. If the  <EM>filename</EM> is set to '-' the image file will be written to standard out. All other
output will get suppressed.

<P>
PNG output is recommended, since it takes up to 40% less disk space and
20-30% less time to generate than a GIF file.

<P>
If no graph functions are called, the graph will not be created.

<DT><STRONG><A NAME="item__s_start">-s|--start seconds (default end-1day)</A></STRONG><DD>
<P>
The time when the graph should begin. Time in seconds since epoch
(1970-01-01) is required. Negative numbers are relative to the current
time. By default one day worth of data will be graphed. See also AT-STYLE
TIME SPECIFICATION section in the <EM>rrdfetch</EM>
documentation for a detailed explanation on how to specify time.

<DT><STRONG><A NAME="item__e_end">-e|--end seconds (default now)</A></STRONG><DD>
<P>
The time when the graph should end. Time in seconds since epoch. See also
AT-STYLE TIME SPECIFICATION section in the <EM>rrdfetch</EM>
documentation for a detailed explanation of ways to specify time.

<DT><STRONG><A NAME="item__x_x_grid">-x|--x-grid x-axis grid and label (default autoconfigure)</A></STRONG><DD>
<P>
The x-axis label is quite complex to configure. So if you don't have very
special needs, you can rely on the autoconfiguration to get this right.

<P>
The x-axis label is configured, using the following format:

<P>
<EM>GTM</EM><STRONG>:</STRONG><EM>GST</EM><STRONG>:</STRONG><EM>MTM</EM><STRONG>:</STRONG><EM>MST</EM><STRONG>:</STRONG><EM>LTM</EM>:<EM>LST</EM><STRONG>:</STRONG><EM>LPR</EM><STRONG>:</STRONG><EM>LFM</EM>



<P>
You have to configure three elements making up the x-axis labels and grid.
The base grid (<EM>G??</EM>), the major grid (<EM>M??</EM>) and the labels (<EM>L??</EM>). The configuration is based on the idea that you first specify a well
known amount of time (<EM>?TM</EM>) and then say how many times it has to pass between each grid line or
label (<EM>?ST</EM>). For the label you have to define two additional items: The precision of
the label in seconds (<EM>LPR</EM>) and the strftime format used to generate the text of the label (<EM>LFM</EM>).

<P>
The <EM>?TM</EM> elements must be one of the following keywords: <STRONG>SECOND</STRONG>,
<STRONG>MINUTE</STRONG>, <STRONG>HOUR</STRONG>, <STRONG>DAY</STRONG>, <STRONG>WEEK</STRONG>, <STRONG>MONTH</STRONG> or <STRONG>YEAR</STRONG>.

<P>
If you wanted a graph with a base grid every 10 minutes and a major one
every hour, with labels every hour you would use the following x-axis
definition.

<P>
<CODE>MINUTE:10:HOUR:1:HOUR:1:0:%X</CODE>



<P>
The precision in this example is 0 because the <CODE>%X</CODE> format is
exact. If the label was the name of the day, we would have had a precision
of 24 hours, because when you say something like 'Monday' you mean the
whole day and not Monday morning 00:00. Thus the label should be positioned
at noon. By defining a precision of 24 hours or rather 86400 seconds, you
make sure that this happens.

<DT><STRONG><A NAME="item__y_y_grid">-y|--y-grid grid step:label factor (default autoconfigure)</A></STRONG><DD>
<P>
Makes vertical grid lines appear at <EM>grid step</EM> interval. Every
<EM>label factor</EM> gridstep, a major grid line is printed, along with label showing the value
of the grid line.

<DT><STRONG><A NAME="item__alt_y_grid">--alt-y-grid</A></STRONG><DD>
<P>
Place Y grid dynamically based on graph Y range. Algorithm ensures that you
always have grid, that there are enough but not too many grid lines and the
grid is metric. That is grid lines are placed every 1, 2, 5 or 10 units.
(contributed by Sasha Mikheev)

<DT><STRONG><A NAME="item__alt_autoscale">--alt-autoscale</A></STRONG><DD>
<P>
Compute Y range based on function absolute minimum and maximum values.
Default algorithm uses predefined set of ranges. This is good in many cases
but it fails miserably when you need to graph something like 260 + 0.001 *
<CODE>sin(x).</CODE> Default algorithm will use Y range from 250 to 300 and
on the graph you will see almost straight line. With --alt-autoscale Y
range will be from slightly less the 260 - 0.001 to slightly more then 260
+ 0.001 and periodic behavior will be seen. (contributed by Sasha Mikheev)

<DT><STRONG><A NAME="item__v_vertical_label">-v|--vertical-label text</A></STRONG><DD>
<P>
vertical label on the left side of the graph. This is normally used to
specify the units used.

<DT><STRONG><A NAME="item__w_width">-w|--width pixels (default 400 pixel)</A></STRONG><DD>
<P>
Width of the drawing area within the graph. This affects the size of the
gif.

<DT><STRONG><A NAME="item__h_height">-h|--height pixels (default 100 pixel)</A></STRONG><DD>
<P>
Width of the drawing area within the graph. This affects the size of the
gif.

<DT><STRONG><A NAME="item__i_interlaced">-i|--interlaced (default: false)</A></STRONG><DD>
<P>
If you set this option, then the resulting GIF will be interlaced. Most web
browsers display these incrementally as they load. If you do not use this
option, the GIFs default to being progressive scanned. The only effect of
this option is to control the format of the GIF on disk. It makes no
changes to the layout or contents of the graph.

<DT><STRONG><A NAME="item__f_imginfo">-f|--imginfo formatstring</A></STRONG><DD>
<P>
After the image has been created, the graph function uses printf together
with this format string to create output similar to the PRINT function,
only that the printf is supplied with the parameters
<EM>filename</EM>, <EM>xsize</EM> and <EM>ysize</EM>. In order to generate an <STRONG>IMG</STRONG> tag suitable for including the graph into a web page, the command line
would look like this:

<P>
<PRE> --imginfo '&lt;IMG SRC=&quot;/img/%s&quot; WIDTH=&quot;%lu&quot; HEIGHT=&quot;%lu&quot; ALT=&quot;Demo&quot;&gt;'
</PRE>
<DT><STRONG><A NAME="item__a_imgformat">-a|--imgformat GIF|PNG (default: GIF)</A></STRONG><DD>
<P>
Allows you to produce PNG output from rrdtool. 

<DT><STRONG><A NAME="item__z_lazy">-z|--lazy (default: false)</A></STRONG><DD>
<P>
Only generate the graph, if the current gif is out of date or not existent.

<DT><STRONG><A NAME="item__u_upper_limit">-u|--upper-limit value (default autoconfigure)</A></STRONG><DD>
<P>
This is not the upper limit of a graph! But rather, this is the minimum
upper bound of a graph. Use this to expand graphs up. For example, the
value 100 will result in graphs that have a upper bound of 100 or more.
Setting the upper limit to the maximum value for some DS will result in
disabling RRDtool's autoscaling down (ie it will ``expand'' graphs up.) To
disable RRDtool's autoscaling up (to the max value for the DSs graphed),
use a nifty CDEF like so: CDEF:mcpu=cpu,100,GT,100,cpu,IF. If this CDEF is
applied to all DSs in a graph, then the graph will have an upper limit of
100.

<DT><STRONG><A NAME="item__l_lower_limit">-l|--lower-limit value (default autoconfigure)</A></STRONG><DD>
<P>
This is not the lower limit of a graph. But rather, this is the maximum
lower bound of a graph. For example, the value -100 will result in a graph
that has a lower limit of -100 or less. Use this keyword to expand graphs
down.

<DT><STRONG><A NAME="item__r_rigid">-r|--rigid</A></STRONG><DD>
<P>
rigid boundaries mode. Normally rrdgraph will automatically expand the
lower and upper limit if the graph contains a value outside the valid
range. With the r option you can disable this behavior

<DT><STRONG><A NAME="item__b_base">-b|--base value</A></STRONG><DD>
<P>
if you are graphing memory (and NOT network traffic) this switch should be
set to 1024 so that one Kb is 1024 byte. For traffic measurement, 1 kb/s is
1000 b/s.

<DT><STRONG><A NAME="item__o_logarithmic">-o|--logarithmic</A></STRONG><DD>
<P>
logarithmic y-axis scaling

<DT><STRONG><A NAME="item__c_color">-c|--color COLORTAG#rrggbb (default colors)</A></STRONG><DD>
<P>
override the colors for the standard elements of the graph. The <EM>COLORTAG</EM>
must be one of the following symbolic names: <STRONG>BACK</STRONG> ground, <STRONG>CANVAS</STRONG>,
<STRONG>SHADEA</STRONG> left/top border, <STRONG>SHADEB</STRONG> right/bottom border, <STRONG>GRID</STRONG>, <STRONG>MGRID</STRONG>
major grid, <STRONG>FONT</STRONG>, <STRONG>FRAME</STRONG> and axis of the graph or <STRONG>ARROW</STRONG>. This option can be called multiple times to set several colors.

<DT><STRONG><A NAME="item__t_title">-t|--title text (default no title)</A></STRONG><DD>
<P>
Define a title to be written into the graph

<DT><STRONG><A NAME="item_DEF">DEF:vname=rrd:ds-name:CF</A></STRONG><DD>
<P>
Define virtual name for a data source. This name can then be used in the
functions explained below. The DEF call automatically chooses an <STRONG>RRA</STRONG> which contains <EM>CF</EM> consolidated data in a resolution appropriate for the size of the graph to
be drawn. Ideally this means that one data point from the <STRONG>RRA</STRONG> should be represented by one pixel in the graph. If the resolution of the <STRONG>RRA</STRONG> is higher than the resolution of the graph, the data in the RRA will be
further consolidated according to the consolidation function (<EM>CF</EM>) chosen.

<DT><STRONG><A NAME="item_CDEF">CDEF:vname=rpn-expression</A></STRONG><DD>
<P>
Create a new virtual data source by evaluating a mathematical expression,
specified in Reverse Polish Notation (RPN). If you have ever used a
traditional HP calculator you already know RPN. The idea behind RPN
notation is, that you have a stack and push your data onto this stack. When
ever you execute an operation, it takes as many data values from the stack
as needed. The pushing of data is implicit, so when ever you specify a
number or a variable, it gets pushed automatically. 

<P>
If this is all a big load of incomprehensible words for you, maybe an
example helps (a more complete explanation is given in [1]): The expression <EM>vname+3/2</EM> becomes <CODE>vname,3,2,/,+</CODE> in RPN. First the three values get pushed onto the stack (which now
contains (the current value of) vname, a 3 and a 2). Then the / operator
pops two values from the stack (3 and 2), divides the first argument by the
second (3/2) and pushes the result (1.5) back onto the stack. Then the +
operator pops two values (vname and 1.5) from the stack; both values are
added up and the result gets pushes back onto the stack. In the end there
is only one value left on the stack: The result of the expression.

<P>
The <EM>rpn-expression</EM> in the <STRONG>CDEF</STRONG> function takes both, constant values as well as <EM>vname</EM> variables. The following operators can be used on these values: 

<DL>
<DT><STRONG><A NAME="item__">+, -, *, /, %</A></STRONG><DD>
<P>
pops two values from the stack applies the selected operator and pushes the
result back onto the stack. The % operator stands for the modulo operation.

<DT><STRONG><A NAME="item_SIN">SIN, COS, LOG, EXP</A></STRONG><DD>
<P>
pops one value from the stack, applies the selected function and pushes the
result back onto the stack.

<DT><STRONG><A NAME="item_LT">LT, LE, GT, GE, EQ</A></STRONG><DD>
<P>
pops two values from the stack, compares them according to the selected
condition and pushes either 1 back onto the stack if the condition is true
and 0 if the condition was not true.

<DT><STRONG><A NAME="item_IF">IF</A></STRONG><DD>
<P>
pops three values from the stack. If the last value is not 0, the second
value will be pushed back onto the stack, otherwise the first value is
pushed back.

<P>
If the stack contains the values A, B, C, D, E are presently on the stack,
the IF operator will pop the values E D and C of the stack. It will look at
C and if it is not 0 it will push D back onto the stack, otherwise E will
be sent back to the stack.

<DT><STRONG><A NAME="item_DUP">DUP, EXC, POP</A></STRONG><DD>
<P>
These manipulate the stack directly. DUP will duplicate the top of the
stack, pushing the result back onto the stack. EXC will exchange the top
two elements of the stack, and POP will pop off the top element of the
stack. Having insufficient elements on the stack for these operations is an
error.

<DT><STRONG><A NAME="item_UN">UN</A></STRONG><DD>
<P>
Pops one value off the stack, if it is <EM>*UNKNOWN*</EM>, 1 will be pushed back otherwise 0.

<DT><STRONG><A NAME="item_UNKN">UNKN</A></STRONG><DD>
<P>
Push an <EM>*UNKNOWN*</EM> value onto the stack.

<DT><STRONG><A NAME="item_PREV">PREV</A></STRONG><DD>
<P>
Push <EM>*UNKNOWN*</EM> if its at the first value of a data set or otherwise the value of this CDEF
at the previous time step. This allows you to perform calculations across
the data.

<DT><STRONG><A NAME="item_INF">INF, NEGINF</A></STRONG><DD>
<P>
Push a positive or negative infinite (oo) value onto the stack. When
drawing an infinite number it appears right at the top or bottom edge of
the graph, depending whether you have a positive or negative infinite
number.

<DT><STRONG><A NAME="item_NOW">NOW</A></STRONG><DD>
<P>
Push the current (real world) time onto the stack.

<DT><STRONG><A NAME="item_TIME">TIME</A></STRONG><DD>
<P>
Push the time the current sample was taken onto the stack.

</DL>
<P>
Please note that you may only use <EM>vname</EM> variables that you previously defined by either <STRONG>DEF</STRONG> or <STRONG>CDEF</STRONG>. Furthermore, as of this writing (version 0.99.25), you must use at least
one <EM>vname</EM>
per expression, that is ``CDEF:fourtytwo=2,40,+'' will yield an error
message but not a <EM>vname</EM> fourtytwo that's always equal to 42.

<DT><STRONG><A NAME="item_PRINT">PRINT:vname:CF:format</A></STRONG><DD>
<P>
Calculate the chosen consolidation function <EM>CF</EM> over the data-source variable <EM>vname</EM> and <CODE>printf</CODE> the result to stdout using <EM>format</EM>. In the <EM>format</EM> string there should be a '%lf' or '%le' marker in the place where the
number should be printed.

<P>
If an additional '%s' is found AFTER the marker, the value will be scaled
and an appropriate SI magnitude unit will be printed in place of the '%s'
marker. The scaling will take the '--base' argument into consideration!

<P>
If a '%S' is used instead of a '%s', then instead of calculating the
appropriate SI magnitude unit for this value, the previously calculated SI
magnitude unit will be used. This is useful if you want all the values in a
PRINT statement to have the same SI magnitude unit. If there was no
previous SI magnitude calculation made, then '%S' behaves like a '%s',
unless the value is 0, in which case it does not remember a SI magnitude
unit and a SI magnitude unit will only be calculated when the next '%s' is
seen or the next '%S' for a non-zero value.

<DT><STRONG><A NAME="item_GPRINT">GPRINT:vname:CF:format</A></STRONG><DD>
<P>
Same as <STRONG>PRINT</STRONG> but the result is printed into the graph below the legend.

<DT><STRONG><A NAME="item_COMMENT">COMMENT:text</A></STRONG><DD>
<P>
Like <STRONG>GPRINT</STRONG> but the <EM>text</EM> is simply printed into the graph.

<DT><STRONG><A NAME="item_HRULE">HRULE:value#rrggbb[:legend]</A></STRONG><DD>
<P>
Draw a horizontal rule into the graph and optionally add a legend

<DT><STRONG><A NAME="item_VRULE">VRULE:time#rrggbb[:legend]</A></STRONG><DD>
<P>
Draw a vertical rule into the graph and optionally add a legend

<DT><STRONG><A NAME="item_LINE">LINE{1|2|3}:vname[#rrggbb[:legend]]</A></STRONG><DD>
<P>
Plot for the requested data, using the color specified. Write a legend into
the graph. The 3 possible keywords <STRONG>LINE1</STRONG>, <STRONG>LINE2</STRONG>, and <STRONG>LINE3</STRONG> 
generate increasingly wide lines. If no color is defined, the drawing is
done 'blind' this is useful in connection with the 
<STRONG>STACK</STRONG> function when you want to ADD the values of two data-sources without
showing it in the graph.

<DT><STRONG><A NAME="item_AREA">AREA:vname[#rrggbb[:legend]]</A></STRONG><DD>
<P>
Does the same as <STRONG>LINE?</STRONG>, but the area between 0 and the graph will be filled with the color
specified.

<DT><STRONG><A NAME="item_STACK">STACK:vname[#rrggbb[:legend]]</A></STRONG><DD>
<P>
Does the same as <STRONG>LINE?</STRONG>, but the graph gets stacked on top of the previous
<STRONG>LINE?</STRONG>, <STRONG>AREA</STRONG> or <STRONG>STACK</STRONG> graph. Depending on the type of the previous graph, the <STRONG>STACK</STRONG> will be either a <STRONG>LINE?</STRONG> or an <STRONG>AREA</STRONG>. This obviously implies that the first <STRONG>STACK</STRONG> must be preceded by an
<STRONG>AREA</STRONG> or <STRONG>LINE?</STRONG> -- you need something to stack something onto in the first place ;) 

<P>
Note, that when you STACK onto *UNKNOWN* data, rrdtool will not draw any
graphics ... *UNKNOWN* is not zero ... if you want it to zero then you
might want to use a CDEF argument with IF and UN functions to turn
*UNKNOWN* into zero ... =back

<H1><A NAME="NOTES_on_legend_arguments">NOTES on legend arguments</A></H1>
<H2><A NAME="Escaping_the_colon">Escaping the colon</A></H2>
<P>
In a ':' in a <EM>legend</EM> argument will mark the end of the legend. To enter a ':' into a legend, the
colon must be escaped with a backslash '\:'. Beware, that many environments
look for backslashes themselves, so it may be necessary to write two
backslashes so that one is passed onto rrd_graph.

<H2><A NAME="String_Formatting">String Formatting</A></H2>
<P>
The text printed below the actual graph can be formated by appending
special escaped characters at the end of a text. When ever such a character
occurs, all pending text is pushed onto the graph according to the
character specified.

<P>
Valid markers are: <STRONG>\j</STRONG> for justified, <STRONG>\l</STRONG> for left aligned, <STRONG>\r</STRONG> for right aligned and <STRONG>\c</STRONG> for centered. In the next section there is an example showing how to use
centered formating.

<P>
Normally there are two space characters inserted between every two items
printed into the graph. The space following a string can be suppressed by
putting a <STRONG>\g</STRONG> at the end of the string. The <STRONG>\g</STRONG> also squshes any space inside the string if it is at the very end of the
string. This can be used in connection with <STRONG>%s</STRONG> to supress empty unit strings.

<P>
<PRE> GPRINT:a:MAX:%lf%s\g
 
A special case is COMMENT:B&lt;\s&gt; this inserts some additional vertical space
before placing the next row of legends.
</PRE>
<H1><A NAME="NOTE_on_Return_Values">NOTE on Return Values</A></H1>
<P>
Whenever rrd_graph gets called, it prints a line telling the size of the
gif it has just created to STDOUT. This line looks like this: XSIZExYSIZE.

<H1><A NAME="EXAMPLE_1">EXAMPLE 1</A></H1>
<P>
<PRE>  rrdtool graph demo.gif --title=&quot;Demo Graph&quot; \
          DEF:cel=demo.rrd:exhaust:AVERAGE \
          &quot;CDEF:far=cel,32,-,0.55555,*&quot; \
          LINE2:cel#00a000:&quot;D. Celsius&quot; \
          LINE2:far#ff0000:&quot;D. Fahrenheit\c&quot;
</PRE>
<H1><A NAME="EXAMPLE_2">EXAMPLE 2</A></H1>
<P>
This example demonstrates the syntax for using IF and UN to set
<EM>*UNKNOWN*</EM> values to 0. This technique is useful if you are aggregating interface data
where the start dates of the data sets doesn't match.

<P>
<PRE>  rrdtool graph demo.gif --title=&quot;Demo Graph&quot; \
         DEF:idat1=interface1.rrd:ds0:AVERAGE \
         DEF:idat2=interface2.rrd:ds0:AVERAGE \
         DEF:odat1=interface1.rrd:ds1:AVERAGE \
         DEF:odat2=interface2.rrd:ds1:AVERAGE \
         CDEF:agginput=idat1,UN,0,idat1,IF,idat2,UN,0,idat2,IF,+,8,* \
         CDEF:aggoutput=odat1,UN,0,odat1,IF,odat2,UN,0,odat2,IF,+,8,* \
         AREA:agginput#00cc00:Input Aggregate \
         LINE1:agginput#0000FF:Output Aggregate
         
Assuming that idat1 has a data value of I&lt;*UNKNOWN*&gt;, the CDEF expression 
</PRE>
<P>
<PRE> idat1,UN,0,idat1,IF 
</PRE>
<P>
leaves us with a stack with contents of 1,0,NaN and the IF function will
pop off the 3 values and replace them with 0. If idat1 had a real value
like 7942099, then the stack would have 0,0,7942099 and the real value
would be the replacement.  

<H1><A NAME="EXAMPLE_3">EXAMPLE 3</A></H1>
<P>
This example shows two ways to use the INF function. First it makes the
background change color during half of the hours. Then, it uses AREA and
STACK to draw a picture. If one of the inputs was UNKNOWN, all inputs are
overlaid with another AREA.

<P>
<PRE>  rrdtool graph example.png --title=&quot;INF demo&quot; \
         DEF:val1=some.rrd:ds0:AVERAGE \
         DEF:val2=some.rrd:ds1:AVERAGE \
         DEF:val3=some.rrd:ds2:AVERAGE \
         DEF:val4=other.rrd:ds0:AVERAGE \
         CDEF:background=val4,POP,TIME,7200,%,3600,LE,INF,UNKN,IF \
         CDEF:wipeout=val1,val2,val3,val4,+,+,+,UN,INF,UNKN,IF \
         AREA:background#F0F0F0 \
         AREA:val1#0000FF:Value1 \
         STACK:val2#00C000:Value2 \
         STACK:val3#FFFF00:Value3 \
         STACK:val4#FFC000:Value4 \
         AREA:whipeout#FF0000:Unknown
</PRE>
<P>
The first CDEF uses val4 as a dummy value. It's value is removed
immediately from the stack. Then a decision is made based on the time that
a sample was taken. If it is an even hour (UTC time !) then the area will
be filled. If it is not, the value is set to UNKN and is not plotted.

<P>
The second CDEF looks if any of val1,val2,val3,val4 is unknown. It does so
by checking the outcome of <CODE>sum(val1,val2,val3,val4).</CODE> Again,
INF is returned when the condition is true, UNKN is used to not plot the
data.

<P>
The different items are plotted in a particular order. First do the
background, then use a normal area to overlay it with data. Stack the other
data until they are all plotted. Last but not least, overlay everything
with eye-hurting red to signal any unknown data.

<P>
Note that this example assumesthat your data is in the positive half of the
y-axis otherwhise you would would have to add NEGINF in order to extend the
coverage of the rea to whole graph.

<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
Tobias Oetiker &lt;<A HREF="mailto:oetiker@ee.ethz.ch">oetiker@ee.ethz.ch</A>&gt;



<H1><A NAME="REFERENCES">REFERENCES</A></H1>
<P>
[1] <A
HREF="http://www.dotpoint.com/xnumber/rpn_or_adl.htm">http://www.dotpoint.com/xnumber/rpn_or_adl.htm</A>


</DL>
</BODY>

</HTML>
