=head1 NAME

rrdtool graph - Create a graph based on data from one or several RRD

=head1 SYNOPSIS

B<rrdtool> B<graph> I<filename> 
S<[B<-s>|B<--start> I<seconds>]> 
S<[B<-e>|B<--end> I<seconds>]>
S<[B<-x>|B<--x-grid> I<x-axis grid and label>]>
S<[B<-y>|B<--y-grid> I<y-axis grid and label>]>
S<[B<-v>|B<--vertical-label> I<text>]>
S<[B<-w>|B<--width> I<pixels>]>
S<[B<-h>|B<--height> I<pixels>]> 
S<[B<-i>|B<--interlaced>]> 
S<[B<-o>|B<--logarithmic>]>
S<[B<-u>|B<--upper-limit> I<value>]> 
S<[B<-l>|B<--lower-limit> I<value>]>
S<[B<-r>|B<--rigid>]>
S<[B<-b>|B<--base> I<value>]>
S<[B<-c>|B<--color> I<COLORTAG>B<#>I<rrggbb>]>
S<[B<-t>|B<--title> I<title>]>
S<[B<DEF:>I<vname>B<=>I<rrd>B<:>I<ds-name>B<:>I<CF>]>
S<[B<CDEF:>I<vname>B<=>I<rpn-expression>]>
S<[B<PRINT:>I<vname>B<:>I<CF>B<:>I<format>]>
S<[B<GPRINT:>I<vname>B<:>I<CF>B<:>I<format>]>
S<[B<COMMENT:>I<text>]>
S<[B<HRULE:>I<value>B<#>I<rrggbb>[B<:>I<legend>]]>
S<[B<VRULE:>I<time>B<#>I<rrggbb>[B<:>I<legend>]]>
S<[B<LINE>{B<1>|B<2>|B<3>}B<:>I<vname>[B<#>I<rrggbb>[B<:>I<legend>]]]>
S<[B<AREA:>I<vname>[B<#>I<rrggbb>[B<:>I<legend>]]]>
S<[B<STACK:>I<vname>[B<#>I<rrggbb>[B<:>I<legend>]]]>

=head1 DESCRIPTION

The B<graph> functions main purpose is to create graphical
representations of the data stored in one or several B<RRD>s. Apart
from generating graphs, it can also extract numerical reports.

=over 8

=item I<filename> 

The name of the graph to generate. Since B<rrdtool> outputs
GIF's, it's recommended that the filename end in F<.gif>.
B<rrdtool> does not enforce this, however. If the  I<filename>
is et to '-' the gif file will be written to standard out. All
other output will get supressd.

If no graph functions are called, the graph will not be created.

=item B<-s>|B<--start> I<seconds> (default -24*3600)

The time when the graph should begin. Time in seconds since
epoch (1970-01-01) is required. Negative numbers are relative to the
end time. By default one day worth of data will be graphed.
See also AT-STYLE TIME SPECIFICATION section in the I<rrdfetch>
documentation for alternative ways to specify start time.

=item B<-e>|B<--end> I<seconds> (default current time)

The time when the graph should end. Time in seconds since epoch.
See also AT-STYLE TIME SPECIFICATION section in the I<rrdfetch>
documentation for alternative ways to specify end time.

=item B<-x>|B<--x-grid> I<x-axis grid and label> (default autoconfigure)

The x-axis label is quite complex to configure. So if you don't have
very special needs, you can relay on the autoconfiguration to get this
right.

The x-axis label is configured, using the following format:

I<GTM>B<:>I<GST>B<:>I<MTM>B<:>I<MST>B<:>I<LTM>:I<LST>B<:>I<LPR>B<:>I<LFM>

You have to configure three elements making up the x-axis labels and
grid. The base grid (I<G??>), the major grid (I<M??>) and the labels
(I<L??>). The configuration is based on the idea that you first
specify a well known amount of time (I<?TM>) and then say how many
times it has to pass between each grid line or label (I<?ST>). For the
label you have to define two additional items: The precision of the
label in seconds (I<LPR>) and the strftime format used to generate the
text of the label (I<LFM>).

The I<?TM> elements must be one of the following keywords: B<SECOND>,
B<MINUTE>, B<HOUR>, B<DAY>, B<WEEK>, B<MONTH> or B<YEAR>.

If you wanted a graph with a base grid every 10 minutes and a major
one every hour, with labels every hour you would use the following
x-axis definition.

C<MINUTE:10:HOUR:1:HOUR:1:0:%X>

The precision in this example is 0 because the %X format is exact. If
the label was the name of the day, we would have had a precision of 24
hours, because when you say something like 'Monday' you mean the whole
day and not Monday morning 00:00. Thus the label should be positioned
at noon. By defining a precision of 24 hours or rather 86400 seconds,
you make sure that this happens.

=item B<-y>B<--y-grid> I<grid step>:I<label factor> (default autoconfigure)

Makes vertical grid lines appear at I<grid step> interval. Every
I<label factor> gridstep, a major grid line is printed, along with
label showing the value of the grid line.

=item B<-v>|B<--vertical-label> I<text>

vertical label on the left side of the graph. This is normally used to
specify the units used.

=item B<-w>|B<--width> I<pixels> (default 400 pixel)

Width of the drawing area within the graph. This affects the size of the
gif.

=item B<-h>|B<--height> I<pixels> (default 100 pixel)

Width of the drawing area within the graph. This affects the size of the
gif.

=item B<-i>|B<--interlaced> (default: false)

If you set this option, then the resulting GIF will be interlaced.
Most web browsers display these incrementally as they load. If
you do not use this option, the GIFs default to being progressive
scanned. The only effect of this option is to control the format
of the GIF on disk. It makes no changes to the layout or contents
of the graph.

=item B<-u>|B<--upper-limit> I<value> (default autoconfigure)

The maximum value to be graphed. By default This will be
autoconfigured from the data you select with the graphing functions.

=item B<-l>|B<--lower-limit> I<value> (default autoconfigure)

The minimum value to be graphed. By default This will be
autoconfigured from the data you select with the graphing functions.

=item B<-r>|B<--rigid>

rigid boundaries mode.  Normally rrdgraph will automatically expand the
lower and upper limit if the graph contains a value outside the valid
range. With the r option you can disable this behavior

=item B<-b>|B<--base> I<value>

if you are graphing memmory (and NOT network traffic) this switch
should be set to 1024 so that one Kb is 1024 byte. For traffic
measurement, 1 kb/s is 1000 b/s.

=item B<-o>|B<--logarithmic>

logarithmic y-axis scaling

=item B<-c>|B<--color> I<COLORTAG>B<#>I<rrggbb> (default colors)

override the colors for the standard elements of the graph. The I<COLORTAG>
must be one of the following symbolic names: B<BACK> ground, B<CANVAS>,
B<SHADEA> left/top border, B<SHADEB> right/bottom border, B<GRID>, B<MGRID>
major grid, B<FONT>, B<FRAME> and axis of the graph or B<ARROW>. This option
can be called multiple times to set several colors.

=item B<-t>|B<--title> I<text> (default no title)

Define a title to be written into the graph

=item B<DEF:>I<vname>B<=>I<rrd>B<:>I<ds-name>B<:>I<CF>

Define virtual name for a data source. This name can then be used
in the functions explained below. The
DEF call automatically chooses an B<RRA> which provides data in a
resolution appropriate for the size of the graph to be drawn.  Ideally
this means that one data point from the B<RRA> should be represented
by one pixel in the graph.  If the resolution of the B<RRA> is higher
than the resolution of the graph, the data in the RRA will be
consolidated according to the consolidation function (I<CF>) chosen.

=item B<CDEF:>I<vname>B<=>I<rpn-expression>

Create a new virtual data source by evaluating a mathematical expression,
specified in Reverse Polish Notation (RPN). If you have ever used a traditional
HP calculator you already know RPN. The idea behind RPN notation is, 
that you have a stack and push your data onto this stack. When ever
you execute an operation, it takes as many data values from the stack
as needed. The pushing of data is implicit, so when ever you specify a number
or a variable, it gets pushed automatically. 

If this is all a big load of 
incomprehensible words for you, maybe an example helps (a more
complete explanation is given in [1]):
The expression 
vname+3/2 becomes vname,3,2,/,+ in RPN. First the three values get
pushed onto the stack (which now contains (the current value of)
vname, a 3 and a 2).
Then the / operator pops two values from the stack (3 and 2), divides
the first argument by the second (3/2) and pushes the result (1.5)
back onto the stack. Then the + operator pops two values (vname and
1.5) from the stack; both values are added up and the result gets
pushes back onto the stack. In the end there is only one value left on
the stack: The result of the expression.

The I<rpn-expression> in the B<CDEF> function takes both, constant values
as well as I<vname> variables. The following operators can be used on these
values: 

=over 8

=item +, -, *, /

pops two values from the stack applies the selected operator and pushes 
the result back onto the stack.

=item SIN, COS, LOG, EXP

pops one value from the stack, applies the selected function and pushes
the result back onto the stack.

=item LT, LE, GT, GE, EQ

pops two values from the stack, compares them according to the selected
condition and pushes either 1 back onto the stack if the condition is true
and 0 if the condition was not true.



=item IF

pops three values from the stack. If the last value is not 0, the
second value will be pushed back onto the stack, otherwise the
first value is pushed back.

If the stack contains the values A, B, C, D, E are presently on the
stack, the IF operator will pop the values E D and C of the stack. It will
look at C and if it is not 0 it will push D back onto the stack, otherwise
E will be sent back to the stack.

=item UN

Pops one value of the stack, if it is I<*UNKNOWN*>, 1 will be pushed
back otherwise 0.

=back

Please note that you may only use I<vname> variables that you
previously defined by either B<DEF> or B<CDEF>. Furthermore, as of
this writing (version 0.99.25), you must use at least one I<vname>
per expression, that is "CDEF:fourtytwo=2,40,+" will yield an error
message but not a I<vname> fourtytwo that's always equal to 42.

=item B<PRINT:>I<vname>B<:>I<CF>B<:>I<format>

Calculate the chosen consolidation function I<CF> over the data-source
variable I<vname> and C<printf> the
result to stdout using I<format>. 

=item B<GPRINT:>I<vname>B<:>I<CF>B<:>I<format>

Same as B<PRINT> but the result is printed into the graph below the legend.

=item B<COMMENT:>I<text>

Like B<GPRINT> but the I<text> is simply printed into the graph.

=item B<HRULE:>I<value>B<#>I<rrggbb>[B<:>I<legend>]

Draw a horizontal rule into the graph and optionally add a legend

=item B<VRULE:>I<time>B<#>I<rrggbb>[B<:>I<legend>]

Draw a vertical rule into the graph and optionally add a legend

=item B<LINE>{B<1>|B<2>|B<3>}B<:>I<vname>[B<#>I<rrggbb>[B<:>I<legend>]]

Plot for the requested data, using the color specified. Write a legend
into the graph. The 3 possible keywords B<LINE1>, B<LINE2>, and B<LINE3> 
generate increasingly wide lines. If no color is defined, 
the drawing is done 'blind' this is useful in connection with the 
B<STACK> function when you want to ADD the values of two 
data-sources without showing it in the graph.

=item B<AREA>:I<vname>[B<#>I<rrggbb>[B<:>I<legend>]]

Does the same as B<LINE?>, but the area between 0 and 
the graph will be filled with the color specified.

=item B<STACK>:I<vname>[B<#>I<rrggbb>[B<:>I<legend>]]

Does the same as B<LINE?>, but the graph gets stacked on top of the previous
B<LINE?>, B<AREA> or B<STACK> graph. Depending on the type of the
previous graph, the B<STACK> will be either a B<LINE?> or an B<AREA>.
This obviously implies that the first B<STACK> must be preceeded by an
B<AREA> or B<LINE?> -- you need something to stack something onto in
the first place ;) 

=back

=head1 NOTE

In a ':' in a I<legend> argument will mark the end of the legend. To
enter a ':' into a legend, the colon must be escaped with a backslash '\:'.
Beware, that many environments look for backslashes themselves, so it may
be necessary to write two backslashes so that one is passed onto rrd_graph.

=head1 NOTE 2

The text printed below the actual graph can be formated by appending special
escaped charactes at the end of a text. When ever such a character occurs,
all pending text is pushed onto the grah acording to the character specified.

Valid characters are: B<j> for justified, B<l> for left aligned, B<r>
for right aligned and B<c> for centered. In the next section there is an example
showing how to use centered formating. 

A special case is COMMENT:\s this inserts some additional vertical space before
placing the next row of legends. 

=head1 NOTE 3

Whenever rrd_graph gets called, it prints a line telling the size of
the gif it has just created to STDOUT. This line looks like this: XSIZExYSIZE.

=head1 EXAMPLE

  rrdtool graph demo.gif --title="Demo Graph" \
          DEF:cel=demo.rrd:exhaust:AVERAGE \
          "CDEF:far=cel,32,-,0.55555,*" \
          LINE2:cel#00a000:"D. Celsius" \
          LINE2:far#ff0000:"D. Fahrenheit\c"

=head1 AUTHOR

Tobias Oetiker <oetiker@ee.ethz.ch>

=head1 REFERENCES

[1] http://www.dotpoint.com/xnumber/rpn_or_adl.htm


