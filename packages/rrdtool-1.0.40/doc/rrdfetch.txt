RRDFETCH(1)                  rrdtool                  RRDFETCH(1)



NNNNAAAAMMMMEEEE
       rrdtool fetch - fetch data from an rrd.

SSSSYYYYNNNNOOOOPPPPSSSSIIIISSSS
       rrrrrrrrddddttttoooooooollll ffffeeeettttcccchhhh _f_i_l_e_n_a_m_e _C_F [--------rrrreeeessssoooolllluuuuttttiiiioooonnnn|----rrrr _r_e_s_o_l_u_t_i_o_n]
       [--------ssssttttaaaarrrrtttt|----ssss _s_t_a_r_t] [--------eeeennnndddd|----eeee _e_n_d]

DDDDEEEESSSSCCCCRRRRIIIIPPPPTTTTIIIIOOOONNNN
       The ffffeeeettttcccchhhh function is normally used internally by the
       graph function, to get data from RRRRRRRRDDDDs. ffffeeeettttcccchhhh will analyze
       the RRRRRRRRDDDD and will try to retrieve the data in the resolu-
       tion requested.  The data fetched is printed to stdout.
       _*_U_N_K_N_O_W_N_* data is often represented by the string "NaN"
       depending on your OSs printf function.

       _f_i_l_e_n_a_m_e
               the name of the RRRRRRRRDDDD you want to fetch the data
               from.

       _C_F      which consolidation function should have been
               applied to the data you want to fetch? (AVER-
               AGE,MIN,MAX,LAST)

       --------rrrreeeessssoooolllluuuuttttiiiioooonnnn|----rrrr _r_e_s_o_l_u_t_i_o_n (default is the highest resolu-
       tion)
               what interval should the values have (seconds per
               value). rrrrrrrrddddffffeeeettttcccchhhh will try to match your request,
               but it will return data even if no absolute match
               is possible. NNNNBBBB.... See note below.

       --------ssssttttaaaarrrrtttt|----ssss _s_t_a_r_t (default end-1day)
               when should the data begin. A time in seconds
               since epoch (1970-01-01) is required. Negative
               numbers are relative to the current time. By
               default one day worth of data will be fetched. See
               also AT-STYLE TIME SPECIFICATION section for a
               detailed explanation on  ways to specify start
               time.

       --------eeeennnndddd|----eeee _e_n_d (default now)
               when should the data end. Time in seconds since
               epoch. See also AT-STYLE TIME SPECIFICATION sec-
               tion for a detailed explanation of how to specify
               end time.

       RRRREEEESSSSOOOOLLLLUUUUTTTTIIIIOOOONNNN IIIINNNNTTTTEEEERRRRVVVVAAAALLLL

       In order to get rrdtool to fetch anything other than the
       finest resolution RRA bbbbooootttthhhh the start and end time must be
       specified on boundaries that are multiples of the wanted
       resolution. Consider the following example:

        rrdtool create subdata.rrd -s 10 DS:ds0:GAUGE:300:0:U \
         RRA:AVERAGE:0.5:30:3600 \
         RRA:AVERAGE:0.5:90:1200 \
         RRA:AVERAGE:0.5:360:1200 \
         RRA:MAX:0.5:360:1200 \
         RRA:AVERAGE:0.5:8640:600 \
         RRA:MAX:0.5:8640:600

       This RRD collects data every 10 seconds and stores its
       averages over 5 minutes, 15 minutes, 1 hour and 1 day as
       well as the maxima for 1 hour and 1 day.

       Consider now that you want too fetch the 15 minute average
       data for last hour.  So you might try

        rrdtool fetch subdata.rrd AVERAGE -r 900 -s -1h

       However, this will almost always result in a time series
       that is NNNNOOOOTTTT in the 15 minute RRA. Therefore the highest
       resolution RRA, i.e. 5 minute averages, will be chosen
       which, in this case, is not what you want.

       Hence, make sure that

       1. both start and end time are a multiple of 900

       2. both start and end time are within the wanted RRA

       So, if time now is called "t",

        do end time == int(t/900)*900,
        start time == end time -1hour, resolution == 900.

       In e.g. bash this could look as:

        TIME=$(date +%s); RRDRES=900; rrdtool fetch subdata.rrd AVERAGE -r $RRDRES \
        -e $(echo $(($TIME/$RRDRES*$RRDRES))) -s e-1h

       Or in perl:

        perl -e '$ctime = time; $rrdres = 900; system "rrdtool fetch subdata.rrd AVERAGE \
        -r $rrdres -e @{[int($ctime/$rrdres)*$rrdres]} -s e-1h"'


       AAAATTTT----SSSSTTTTYYYYLLLLEEEE TTTTIIIIMMMMEEEE SSSSPPPPEEEECCCCIIIIFFFFIIIICCCCAAAATTTTIIIIOOOONNNN

       Apart from the traditional _S_e_c_o_n_d_s _s_i_n_c_e _e_p_o_c_h, rrdtool
       does also understand at-style time specification.  The
       specification is called "at-style" after Unix command
       _a_t(1) that has moderately complex ways to specify time to
       run your job at.  The at-style specification consists of
       two parts: TTTTIIIIMMMMEEEE RRRREEEEFFFFEEEERRRREEEENNNNCCCCEEEE specification and TTTTIIIIMMMMEEEE OOOOFFFFFFFFSSSSEEEETTTT
       specification.

       TTTTIIIIMMMMEEEE RRRREEEEFFFFEEEERRRREEEENNNNCCCCEEEE SSSSPPPPEEEECCCCIIIIFFFFIIIICCCCAAAATTTTIIIIOOOONNNN

       Time reference specification is used, well,... to estab-
       lish a reference moment in time (for time offset to be
       applied to). When present, it should come first, when
       omitted, it defaults to nnnnoooowwww. On its own part, time refer-
       ence consists of _t_i_m_e_-_o_f_-_d_a_y reference (which should come
       first, if present) and _d_a_y reference.

       _T_i_m_e_-_o_f_-_d_a_y can be specified as HHHHHHHH::::MMMMMMMM, HHHHHHHH....MMMMMMMM, or just HHHHHHHH,
       you can suffix it with aaaammmm or ppppmmmm or use 24-hours clock. The
       few special times of day are understood as well, these
       include mmmmiiiiddddnnnniiiigggghhhhtttt (00:00), nnnnoooooooonnnn (12:00) and British tttteeeeaaaattttiiiimmmmeeee
       (16:00).

       The _d_a_y can be specified as _m_o_n_t_h_-_n_a_m_e _d_a_y_-_o_f_-_t_h_e_-_m_o_n_t_h
       and optional 2- or 4-digit _y_e_a_r number (e.g. March 8
       1999).  Alternatively, you can use _d_a_y_-_o_f_-_w_e_e_k_-_n_a_m_e (e.g.
       Monday), or one of the words: yyyyeeeesssstttteeeerrrrddddaaaayyyy, ttttooooddddaaaayyyy, ttttoooommmmoooorrrrrrrroooowwww.
       You can also specify _d_a_y as a full date in several numeri-
       cal formats; these include: MMMMMMMM////DDDDDDDD////[[[[YYYYYYYY]]]]YYYYYYYY, DDDDDDDD....MMMMMMMM....[[[[YYYYYYYY]]]]YYYYYYYY,
       YYYYYYYYYYYYYYYYMMMMMMMMDDDDDDDD.

       _N_O_T_E_1: this is different from the original _a_t(1) behavior,
       which interprets a single-number date as MMDD[YY]YY.

       _N_O_T_E_2: if you specify _d_a_y this way, the _t_i_m_e_-_o_f_-_d_a_y is
       REQUIRED to be present.

       Finally, you can use words nnnnoooowwww, ssssttttaaaarrrrtttt, or eeeennnndddd as your time
       reference. NNNNoooowwww refers to the current moment (and is also a
       default time reference). SSSSttttaaaarrrrtttt (eeeennnndddd) can be used to spec-
       ify time relative to the start (end) time for those tools
       that use these categories (rrdfetch, rrdgraph).

       Month and weekday names can be used in their naturally
       abbreviated form (e.g., Dec for December, Sun for Sunday,
       etc.). The words nnnnoooowwww, ssssttttaaaarrrrtttt, eeeennnndddd can be abbreviated to nnnn,
       ssss, eeee.

       TTTTIIIIMMMMEEEE OOOOFFFFFFFFSSSSEEEETTTT SSSSPPPPEEEECCCCIIIIFFFFIIIICCCCAAAATTTTIIIIOOOONNNN

       Time offset specification is used to add (or subtract)
       certain time interval to (from) the time reference moment.
       It consists of _s_i_g_n (++++ or ----) and _a_m_o_u_n_t. The following
       time units can be used to specify the _a_m_o_u_n_t: yyyyeeeeaaaarrrrssss,
       mmmmoooonnnntttthhhhssss, wwwweeeeeeeekkkkssss, ddddaaaayyyyssss, hhhhoooouuuurrrrssss, mmmmiiiinnnnuuuutttteeeessss, sssseeeeccccoooonnnnddddssss, these can be
       used in singular or plural form, and abbreviated naturally
       or to a single letter (e.g. +3days, -1wk, -3y). Several
       time units can be combined together (e.g., -5mon1w2d), as
       well as several time offsets can be concatenated (e.g.,
       -5h45min = -5h-45min = -6h+15min = -7h+1h30m-15min, etc.)

       _N_O_T_E_3: If you specify time offset in days, weeks, months,
       or years, you will end with the time offset that may vary
       depending on you time reference, because all those time
       units have no single well defined time interval value
       (1 year contains either 365 or 366 days, 1 month is 28 to
       31 days long, and even 1 day may be not equal to 24 hours
       twice a year, when DST-related clock adjustments take
       place).  To cope with this, when you use days, weeks,
       months, or years as your time offset units your time ref-
       erence date is adjusted accordingly without taking too
       much further effort to ensure anything about it (in the
       hope that _m_k_t_i_m_e(3) will take care of this later).  This
       may lead to some surprising (or even invalid!) results,
       e.g. 'May 31 -1month' = 'Apr 31' (meaningless) = 'May 1'
       (after _m_k_t_i_m_e(3) normalization); in the EET timezone
       '3:30am Mar 29 1999 -1 day' yields '3:30am Mar 28 1999'
       (Sunday) which is invalid time/date combination (because
       of 3am -> 4am DST forward clock adjustment, see the below
       example).  On the other hand, hours, minutes, and seconds
       are well defined time intervals, and these are guaranteed
       to always produce time offsets exactly as specified (e.g.
       for EET timezone, '8:00 Mar 27 1999 +2 days' =
       '8:00 Mar 29 1999', but since there is 1-hour DST forward
       clock adjustment takes place around 3:00 Mar 28 1999, the
       actual time interval between 8:00 Mar 27 1999 and
       8:00 Mar 29 1999 equals 47 hours; on the other hand,
       '8:00 Mar 27 1999 +48 hours' = '9:00 Mar 29 1999', as
       expected)

       _N_O_T_E_4: The single-letter abbreviation for both mmmmoooonnnntttthhhhssss and
       mmmmiiiinnnnuuuutttteeeessss is mmmm. To disambiguate, the parser tries to read
       your mind :) by applying the following two heuristics:

       1  If mmmm is used in context of (i.e. right after the)
          years, months, weeks, or days it is assumed to mean
          mmmmoooonnnntttthhhhssss, while in the context of hours, minutes, and
          seconds it means minutes.  (e.g., in -1y6m or +3w1m mmmm
          means mmmmoooonnnntttthhhhssss, while in -3h20m or +5s2m mmmm means mmmmiiiinnnnuuuutttteeeessss)

       2  Out of context (i.e. right after the ++++ or ---- sign) the
          meaning of mmmm is guessed from the number it directly
          follows.  Currently, if the number absolute value is
          below 25 it is assumed that mmmm means mmmmoooonnnntttthhhhssss, otherwise
          it is treated as mmmmiiiinnnnuuuutttteeeessss.  (e.g., -25m == -25 minutes,
          while +24m == +24 months)

       _F_i_n_a_l _N_O_T_E_S: Time specification is case-insensitive.
       Whitespace can be inserted freely or omitted altogether,
       there are, however, cases when whitespace is required
       (e.g., 'midnight Thu'). In this case you should either
       quote the whole phrase to prevent it from being taken
       apart by your shell or use '_' (underscore) or ',' (comma)
       which also count as whitespace (e.g., midnight_Thu or mid-
       night,Thu)

       TTTTIIIIMMMMEEEE SSSSPPPPEEEECCCCIIIIFFFFIIIICCCCAAAATTTTIIIIOOOONNNN EEEEXXXXAAAAMMMMPPPPLLLLEEEESSSS

       _O_c_t _1_2 -- October 12 this year

       _-_1_m_o_n_t_h or _-_1_m -- current time of day, only a month before
       (may yield surprises, see the NOTE3 above)

       _n_o_o_n _y_e_s_t_e_r_d_a_y _-_3_h_o_u_r_s -- yesterday morning; can be put
       also as _9_a_m_-_1_d_a_y

       _2_3_:_5_9 _3_1_._1_2_._1_9_9_9 -- 1 minute to the year 2000

       _1_2_/_3_1_/_9_9 _1_1_:_5_9_p_m -- 1 minute to the year 2000 for imperi-
       alists

       _1_2_a_m _0_1_/_0_1_/_0_1 -- start of the new millennium

       _e_n_d_-_3_w_e_e_k_s or _e_-_3_w -- 3 weeks before end time (may be used
       as start time specification)

       _s_t_a_r_t_+_6_h_o_u_r_s or _s_+_6_h -- 6 hours after start time (may be
       used as end time specification)

       _9_3_1_2_2_5_5_3_7 -- 18:45  July 5th, 1999 (yes, seconds since
       1970 are valid as well)

       _1_9_9_7_0_7_0_3 _1_2_:_4_5 -- 12:45  July 3th, 1997 (not quote stan-
       dard, but I love this ...)

AAAAUUUUTTTTHHHHOOOORRRR
       Tobias Oetiker <oetiker@ee.ethz.ch>



2002-07-31                    1.0.40                  RRDFETCH(1)
